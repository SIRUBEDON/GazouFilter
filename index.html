<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GazouFilter | ãƒ–ãƒ©ã‚¦ã‚¶ã§ä½¿ãˆã‚‹ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼†åŠ å·¥ãƒ„ãƒ¼ãƒ«</title>
        <meta name="description" content="ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸è¦ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ãã«ä½¿ãˆã‚‹ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ»åŠ å·¥ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚å¤šå½©ãªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã€ãƒ—ãƒªã‚»ãƒƒãƒˆã€ä¸€æ‹¬å‡¦ç†æ©Ÿèƒ½ã§ã€ã‚ãªãŸã®ç”»åƒã‚’ç°¡å˜ã«ãƒ—ãƒ­ç´šã®ä»•ä¸ŠãŒã‚Šã«ã€‚" />
        <meta name="keywords" content="ç”»åƒåŠ å·¥, ç”»åƒç·¨é›†, ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼, ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«, ãƒ–ãƒ©ã‚¦ã‚¶, ç„¡æ–™, ç”»åƒ, åŠ å·¥, ç·¨é›†, ãƒªã‚µã‚¤ã‚º, åœ§ç¸®, ä¸€æ‹¬å‡¦ç†, GazouFilter" />

        <!-- OGP (Open Graph Protocol) -->
        <meta property="og:title" content="GazouFilter | ãƒ–ãƒ©ã‚¦ã‚¶ã§ä½¿ãˆã‚‹ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼†åŠ å·¥ãƒ„ãƒ¼ãƒ«" />
        <meta property="og:description" content="ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸è¦ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ãã«ä½¿ãˆã‚‹ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ»åŠ å·¥ãƒ„ãƒ¼ãƒ«ã€‚å¤šå½©ãªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã€ãƒ—ãƒªã‚»ãƒƒãƒˆã€ä¸€æ‹¬å‡¦ç†æ©Ÿèƒ½ã§ã€ã‚ãªãŸã®ç”»åƒã‚’ç°¡å˜ã«ãƒ—ãƒ­ç´šã®ä»•ä¸ŠãŒã‚Šã«ã€‚" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://sirubedon.github.io/GazouFilter/" />

        <meta property="og:site_name" content="GazouFilter" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:site" content="@qxoiuioxp" />
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <style>
            body {
                font-family: "Inter", "Noto Sans JP", sans-serif;
                overscroll-behavior: none;
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
            }
            .placeholder {
                border: 3px dashed #cbd5e1;
                transition: all 0.3s ease;
            }
            .placeholder.dragover {
                border-color: #3b82f6;
                background-color: #eff6ff;
            }
            #filter-list .filter-item {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.75rem;
                background-color: #f8fafc; /* slate-50 */
                border: 1px solid #e2e8f0; /* slate-200 */
                border-radius: 0.5rem;
            }
            #filter-list .filter-item:not(:last-child) {
                margin-bottom: 0.5rem;
            }
            .handle {
                cursor: move;
                color: #9ca3af;
            }
            .ghost {
                opacity: 0.4;
                background: #c8ebfb;
            }

            .tab-btn {
                padding: 0.5rem 1rem;
                border-bottom: 2px solid transparent;
                color: #64748b; /* slate-500 */
                font-weight: 500;
                white-space: nowrap;
            }
            .tab-btn.active {
                color: #3b82f6; /* blue-600 */
                border-color: #3b82f6; /* blue-600 */
            }
            .filter-add-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 0.25rem;
                padding: 0.5rem;
                border-radius: 0.5rem;
                background-color: #f1f5f9; /* slate-100 */
                transition: all 0.2s ease;
                text-align: center;
                width: 100%;
                height: 100%;
            }
            .filter-add-btn:hover {
                background-color: #e2e8f0; /* slate-200 */
                color: #3b82f6;
            }
            .filter-add-btn span {
                font-size: 0.75rem;
                line-height: 1.1;
            }

            /* Mobile optimizations */
            @media (max-width: 768px) {
                .container {
                    padding: 1rem !important;
                }
                input[type="range"] {
                    height: 2rem;
                    -webkit-appearance: none;
                    appearance: none;
                }
                input[type="range"]::-webkit-slider-thumb {
                    width: 1.5rem;
                    height: 1.5rem;
                }
                input[type="range"]::-moz-range-thumb {
                    width: 1.5rem;
                    height: 1.5rem;
                }
                .filter-item {
                    padding: 1rem !important;
                }
                button {
                    min-height: 44px;
                    -webkit-tap-highlight-color: transparent;
                }
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    </head>
    <body class="bg-slate-100 text-slate-800">
        <div class="container mx-auto p-4 md:p-8">
            <header class="text-center mb-8">
                <h1 class="text-3xl md:text-4xl font-bold text-slate-900">
                    GazouFilter | ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ„ãƒ¼ãƒ«
                </h1>
                <p class="text-slate-600 mt-2">
                    ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ãä½¿ãˆã‚‹ã€ç”»åƒåŠ å·¥ãƒ„ãƒ¼ãƒ«âœ¨
                </p>
                <div class="mt-3 text-sm text-slate-500">
                    ä½œæˆè€…: ã—ã‚‹ã¹ (X: <a href="https://x.com/qxoiuioxp" target="_blank" class="text-blue-600 hover:underline">@qxoiuioxp</a>)
                </div>
                <p class="mt-4 text-sm text-emerald-600 font-medium">
                    ãƒ­ãƒ¼ã‚«ãƒ«ã§ã™ã¹ã¦å‡¦ç†ã¯å®Œçµã—ã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã¯ã•ã‚Œã¾ã›ã‚“ã€‚
                </p>
            </header>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <section class="lg:col-span-3 bg-white p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-slate-900 mb-3">æ›´æ–°å±¥æ­´</h2>
                    <ul class="space-y-2 text-sm text-slate-700">
                        <li>
                            <span class="font-semibold">2025/10/09</span> â€” ã‚«ãƒ©ãƒ¼æ•°åœ§ç¸®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®å³å¯†è‰²æ•°åˆ¶é™ï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ã‚«ãƒƒãƒˆï¼‹ãƒ‡ã‚£ã‚¶ãƒ¼ï¼‰å®Ÿè£…ã€ãƒ‰ãƒƒãƒˆçµµé¢¨ãƒ—ãƒªã‚»ãƒƒãƒˆã®èª¿æ•´ã€è‰²æ•°åˆ¶é™ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®è¿½åŠ ãƒœã‚¿ãƒ³ã‚’æ•´å‚™
                        </li>
                        <li>
                            <span class="font-semibold">2025/10/06</span> â€” ãƒ¬ãƒˆãƒ­ãƒ‰ãƒƒãƒˆï¼ˆGBé¢¨ï¼‰ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã¨æ–°ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆãƒ¬ãƒˆãƒ­GBï¼ãƒ•ã‚£ãƒ«ãƒ ï¼ãƒã‚ªãƒ³ï¼‰ã‚’è¿½åŠ ã—ã€ãƒ­ãƒ¼ã‚«ãƒ«å‡¦ç†ã®æ³¨æ„æ›¸ãã‚’æ²è¼‰
                        </li>
                        <li>
                            <span class="font-semibold">2025/10/03</span> â€” ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¿½åŠ ï¼ˆè‰²åå·®ãƒ»ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ãƒ»éœï¼‰ã€æ–¹å‘æ€§ã¼ã‹ã—ã®å‡¦ç†è¦‹ç›´ã—ã€ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã®æ‹¡å¼µå­ç¶­æŒãªã©ã‚’æ”¹å–„
                        </li>
                        <li>
                            <span class="font-semibold">2025/10/01</span> â€” å…¬é–‹
                        </li>
                    </ul>
                </section>

                <!-- Controls Column -->
                <div
                    class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg h-fit space-y-6"
                >
                    <!-- Add Filter Section -->
                    <div>
                        <h3 class="text-lg font-bold text-slate-800 mb-3">
                            1. ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’è¿½åŠ 
                        </h3>
                        <!-- Tab Headers -->
                        <div class="border-b border-gray-200 overflow-x-auto">
                            <nav
                                id="filter-tabs"
                                class="-mb-px flex"
                                aria-label="Tabs"
                            >
                                <button
                                    class="tab-btn active"
                                    data-tab="presets"
                                >
                                    ãƒ—ãƒªã‚»ãƒƒãƒˆ
                                </button>
                                <button class="tab-btn" data-tab="adjust">
                                    èª¿æ•´
                                </button>
                                <button class="tab-btn" data-tab="effects">
                                    åŠ¹æœ
                                </button>
                                <button class="tab-btn" data-tab="special">
                                    ç‰¹æ®Š
                                </button>
                            </nav>
                        </div>
                        <!-- Tab Content -->
                        <div class="pt-4">
                            <div
                                id="tab-content-presets"
                                class="tab-panel grid grid-cols-2 sm:grid-cols-3 gap-3"
                            >
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-orange-400 to-pink-500 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="sunset"
                                >
                                    ğŸŒ… å¤•ç„¼ã‘
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-indigo-900 to-purple-900 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="night"
                                >
                                    ğŸŒ™ å¤œ
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-cyan-400 to-blue-500 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="game"
                                >
                                    ğŸ® ã‚²ãƒ¼ãƒ é¢¨
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-amber-500 via-lime-500 to-emerald-600 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="dot-art"
                                >
                                    ğŸ§© ãƒ‰ãƒƒãƒˆçµµé¢¨
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-red-400 to-yellow-400 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="warm"
                                >
                                    ğŸ”¥ æš–è‰²
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-blue-400 to-cyan-400 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="cool"
                                >
                                    â„ï¸ å¯’è‰²
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-lime-600 to-emerald-700 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="retro-gb"
                                >
                                    ğŸŸ© ãƒ¬ãƒˆãƒ­GB
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-stone-700 to-amber-600 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="film"
                                >
                                    ğŸ“½ ãƒ•ã‚£ãƒ«ãƒ 
                                </button>
                                <button
                                    class="preset-btn p-4 bg-gradient-to-br from-cyan-500 via-purple-600 to-fuchsia-600 text-white rounded-lg hover:shadow-lg transition font-semibold"
                                    data-preset="neon-city"
                                >
                                    ğŸŒ† ãƒã‚ªãƒ³
                                </button>
                            </div>
                            <div
                                id="tab-content-adjust"
                                class="tab-panel hidden grid grid-cols-3 sm:grid-cols-4 gap-2"
                            >
                                <button
                                    class="filter-add-btn"
                                    data-filter="resize"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M4 8V5a1 1 0 011-1h3M20 16v3a1 1 0 01-1 1h-3M16 4h3a1 1 0 011 1v3M8 20H5a1 1 0 01-1-1v-3M9 15l6-6M9 9h0M15 15h0"
                                        ></path></svg
                                    ><span>ãƒªã‚µã‚¤ã‚º</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="brightness"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                                        ></path></svg
                                    ><span>æ˜åº¦</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="contrast"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 18.5A6.5 6.5 0 1012 5.5a6.5 6.5 0 000 13zM12 5.5V1"
                                        ></path></svg
                                    ><span>ï½ºï¾ï¾„ï¾—ï½½ï¾„</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="saturate"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
                                        ></path></svg
                                    ><span>å½©åº¦</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="exposure"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 6.168a5.832 5.832 0 100 11.664 5.832 5.832 0 000-11.664zM12 2v2m0 16v2m-8-9H2m20 0h-2"
                                        ></path></svg
                                    ><span>éœ²å‡º</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="hue-rotate"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M13 10V3L4 14h7v7l9-11h-7z"
                                            transform="rotate(90 12 12)"
                                        ></path></svg
                                    ><span>è‰²ç›¸å›è»¢</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="opacity"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 12c-4.418 0-8-3.582-8-8s3.582-8 8-8 8 3.582 8 8-3.582 8-8 8zm0 0v10"
                                        ></path>
                                        <path
                                            d="M12 12a8 8 0 00-8 8h16a8 8 0 00-8-8z"
                                            style="opacity: 0.5"
                                        ></path></svg
                                    ><span>ä¸é€æ˜åº¦</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="red"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="#ef4444"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M12 12a8 8 0 100-16 8 8 0 000 16z"
                                        /></svg
                                    ><span>èµ¤ãƒãƒ£ãƒ³ãƒãƒ«</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="green"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="#22c55e"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M12 12a8 8 0 100-16 8 8 0 000 16z"
                                        /></svg
                                    ><span>ç·‘ãƒãƒ£ãƒ³ãƒãƒ«</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="blue"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="#3b82f6"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M12 12a8 8 0 100-16 8 8 0 000 16z"
                                        /></svg
                                    ><span>é’ãƒãƒ£ãƒ³ãƒãƒ«</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="temperature"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M9 11l3-3m0 0l3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"
                                        ></path></svg
                                    ><span>è‰²æ¸©åº¦</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="vibrance"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M13 10V3L4 14h7v7l9-11h-7z"
                                        ></path></svg
                                    ><span>è‡ªç„¶ãªå½©åº¦</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="gamma"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"
                                        ></path></svg
                                    ><span>ã‚¬ãƒ³ãƒ</span>
                                </button>
                            </div>
                            <div
                                id="tab-content-effects"
                                class="tab-panel hidden grid grid-cols-3 sm:grid-cols-4 gap-2"
                            >
                                <button
                                    class="filter-add-btn"
                                    data-filter="grayscale"
                                >
                                    <svg
                                        class="w-6 h-6 fill-current text-slate-500"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
                                        ></path></svg
                                    ><span>ï½¸ï¾ï¾šï½°ï½½ï½¹ï½°ï¾™</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="sepia"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"
                                        ></path></svg
                                    ><span>ã‚»ãƒ”ã‚¢</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="invert"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 4v16m8-8H4"
                                        ></path></svg
                                    ><span>åè»¢</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="blur"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M13 10V3L4 14h7v7l9-11h-7z"
                                        ></path></svg
                                    ><span>ã¼ã‹ã—</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="noise"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M2 6h2v2H2V6zm0 4h2v2H2v-2zm0 4h2v2H2v-2zm4 4h2v2H6v-2zM6 2H4v2h2V2zm0 12h2v2H6v-2zM10 2h2v2h-2V2zm0 4h2v2h-2V6zm0 12h2v2h-2v-2zm0-4h2v2h-2v-2zm8 4h2v2h-2v-2zm0-12h2v2h-2V6zm-4 8h2v2h-2v-2zm-4 4h2v2h-2v-2zm8-8h2v2h-2V6zm4 0h2v2h-2V6zm0 4h2v2h-2v-2zm0-8h2v2h-2V2zm-4 0h2v2h-2V2zm4 12h2v2h-2v-2zm-8 4h2v2h-2v-2zm-4-4h2v2H6v-2z"
                                        ></path></svg
                                    ><span>ãƒã‚¤ã‚º</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="vignette"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M12 3C7.03 3 3 7.03 3 12s4.03 9 9 9 9-4.03 9-9-4.03-9-9-9zm0 16c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7z"
                                            opacity=".4"
                                        />
                                        <path
                                            d="M12 5c-3.86 0-7 3.14-7 7s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7z"
                                        /></svg
                                    ><span>ãƒ“ãƒãƒƒãƒˆ</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="colorize"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343"
                                        ></path></svg
                                    ><span>ç€è‰²</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="duotone"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
                                        ></path></svg
                                    ><span>2éšèª¿</span>
                                </button>
                            </div>
                            <div
                                id="tab-content-special"
                                class="tab-panel hidden grid grid-cols-3 sm:grid-cols-4 gap-2"
                            >
                                <button
                                    class="filter-add-btn"
                                    data-filter="threshold"
                                >
                                    <svg
                                        class="w-6 h-6 fill-current text-slate-500"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M12 14l9-5-9-5-9 5 9 5z"
                                        ></path>
                                        <path
                                            d="M12 14l6.16-3.422A12.083 12.083 0 0121 12c0 6.627-5.373 12-12 12S-3 18.627-3 12a12.083 12.083 0 012.84-6.422L12 14z"
                                        ></path></svg
                                    ><span>äºŒå€¤åŒ–</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="pixelate"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M2 2h4v4H2zm5 0h4v4H7zm5 0h4v4h-4zm5 0h4v4h-4zM2 7h4v4H2zm5 0h4v4H7zm5 0h4v4h-4zm5 0h4v4h-4zM2 12h4v4H2zm5 0h4v4H7zm5 0h4v4h-4zm5 0h4v4h-4zM2 17h4v4H2zm5 0h4v4H7zm5 0h4v4h-4zm5 0h4v4h-4z"
                                        ></path></svg
                                    ><span>ãƒ”ã‚¯ã‚»ãƒ«åŒ–</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="dither"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <rect x="3" y="3" width="4" height="4" rx="1" ry="1"></rect>
                                        <rect x="11" y="5" width="4" height="4" rx="1" ry="1"></rect>
                                        <rect x="17" y="3" width="4" height="4" rx="1" ry="1"></rect>
                                        <rect x="5" y="11" width="4" height="4" rx="1" ry="1"></rect>
                                        <rect x="13" y="13" width="4" height="4" rx="1" ry="1"></rect>
                                        <rect x="3" y="17" width="4" height="4" rx="1" ry="1"></rect>
                                        <rect x="17" y="17" width="4" height="4" rx="1" ry="1"></rect>
                                    </svg><span>GBãƒ‰ãƒƒãƒˆ</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="posterize"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M3 21v-4a2 2 0 012-2h14a2 2 0 012 2v4M8 21v-2a2 2 0 012-2h4a2 2 0 012 2v2M4 11v-2a2 2 0 012-2h12a2 2 0 012 2v2M10 11V3"
                                        ></path></svg
                                    ><span>ãƒã‚¹ã‚¿ãƒ©ã‚¤ã‚º</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="colorquant"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M4 7h16M4 12h16M4 17h16M7 4v3M12 4v3M17 4v3M7 17v3M12 17v3M17 17v3"
                                        ></path></svg
                                    ><span>è‰²æ•°åˆ¶é™</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="sharpen"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M3 21l8-18 8 18-16-12h16"
                                        ></path></svg
                                    ><span>ã‚·ãƒ£ãƒ¼ãƒ—</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="emboss"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"
                                        ></path></svg
                                    ><span>ã‚¨ãƒ³ãƒœã‚¹</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="solarize"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 3a9 9 0 00-9 9c0 2.38 1.01 4.6 2.64 6.13M12 3v18M21 12a9 9 0 00-2.64-6.13"
                                        ></path>
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M12 21a9 9 0 009-9"
                                        ></path></svg
                                    ><span>ï½¿ï¾—ï¾˜ï½¾ï¾ï½°ï½¼ï½®ï¾</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="tonecurve"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"
                                        ></path></svg
                                    ><span>ãƒˆãƒ¼ãƒ³ã‚«ãƒ¼ãƒ–</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="edge"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M4 5a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3zM14 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1h-4a1 1 0 01-1-1v-3z"
                                        ></path></svg
                                    ><span>è¼ªéƒ­ç·š</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="bloom"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"
                                        ></path></svg
                                    ><span>ãƒ–ãƒ«ãƒ¼ãƒ </span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="chromatic"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <circle cx="9" cy="12" r="4" stroke-width="1.8"></circle>
                                        <circle cx="15" cy="10" r="4" stroke-width="1.8" opacity="0.7"></circle>
                                        <circle cx="13" cy="15" r="4" stroke-width="1.8" opacity="0.4"></circle>
                                    </svg><span>è‰²åå·®</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="scanlines"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path d="M4 6h16M4 10h16M4 14h16M4 18h16" stroke-width="1.8" stroke-linecap="round"></path>
                                    </svg><span>ï½½ï½·ï½¬ï¾ï¾—ï½²ï¾</span>
                                </button>
                                <button
                                    class="filter-add-btn"
                                    data-filter="haze"
                                >
                                    <svg
                                        class="w-6 h-6"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            d="M5 16h14M4 19h10M7 13a4 4 0 110-8 5.5 5.5 0 0110.7 1.5A3.5 3.5 0 0118.5 13H7z"
                                            stroke-width="1.8"
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                        ></path>
                                    </svg><span>éœ</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Applied Filters Section -->
                    <div>
                        <h3 class="text-lg font-bold text-slate-800 mb-3">
                            2. é©ç”¨ä¸­ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                        </h3>
                        <div
                            id="filter-list-container"
                            class="bg-slate-100 p-3 rounded-lg min-h-[100px] space-y-2"
                        >
                            <div id="filter-list"></div>
                            <p
                                id="no-filters-msg"
                                class="text-center text-slate-500 text-sm py-4"
                            >
                                ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“
                            </p>
                        </div>
                    </div>

                    <!-- Actions Section -->
                    <div>
                        <h3 class="text-lg font-bold text-slate-800 mb-3">
                            3. ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                        </h3>
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                            <button
                                id="upload-btn"
                                class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition"
                            >
                                <svg
                                    class="w-5 h-5"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                                    ></path></svg
                                >é–‹ã
                            </button>
                            <button
                                id="batch-upload-btn"
                                class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition"
                            >
                                <svg
                                    class="w-5 h-5"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                                    ></path></svg
                                >ä¸€æ‹¬
                            </button>
                            <button
                                id="save-btn"
                                class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition"
                            >
                                <svg
                                    class="w-5 h-5"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
                                    ></path></svg
                                >ä¿å­˜
                            </button>
                            <div class="relative">
                                <button
                                    id="compress-btn"
                                    class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition"
                                >
                                    <svg
                                        class="w-5 h-5"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
                                        ></path></svg
                                    >åœ§ç¸®
                                </button>
                                <div id="compress-menu" class="hidden absolute bottom-full mb-1 left-0 right-0 bg-white rounded-lg shadow-lg border border-slate-200 overflow-hidden z-10">
                                    <button class="compress-option w-full px-4 py-2 text-left text-sm hover:bg-slate-100 transition" data-format="png">PNGå½¢å¼ã§åœ§ç¸®</button>
                                    <button class="compress-option w-full px-4 py-2 text-left text-sm hover:bg-slate-100 transition" data-format="jpeg">JPEGå½¢å¼ã§åœ§ç¸®</button>
                                </div>
                            </div>
                            <button
                                id="resize-btn"
                                class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition"
                            >
                                <svg
                                    class="w-5 h-5"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
                                    ></path></svg
                                >ãƒªã‚µã‚¤ã‚º
                            </button>
                            <button
                                id="reset-btn"
                                class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition"
                            >
                                <svg
                                    class="w-5 h-5"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                    ></path></svg
                                >ãƒªã‚»ãƒƒãƒˆ
                            </button>
                        </div>
                    </div>

                    <!-- How to Use Section -->
                    <div class="mt-6 p-4 bg-blue-50 rounded-lg">
                        <h3 class="text-md font-bold text-slate-800 mb-2">ä½¿ã„æ–¹</h3>
                        <ol class="text-sm text-slate-700 space-y-1 list-decimal list-inside">
                            <li>ç”»åƒã‚’é–‹ããƒœã‚¿ãƒ³ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§èª­ã¿è¾¼ã¿</li>
                            <li><strong>ãƒ—ãƒªã‚»ãƒƒãƒˆ</strong>ã§å³åº§ã«é›°å›²æ°—ã‚’å¤‰æ›´ã€ã¾ãŸã¯å€‹åˆ¥ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’è¿½åŠ </li>
                            <li>ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§å¼·åº¦ã‚’èª¿æ•´</li>
                            <li>ä¿å­˜ãƒœã‚¿ãƒ³ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</li>
                            <li>ä¸€æ‹¬ãƒœã‚¿ãƒ³ã§è¤‡æ•°ç”»åƒã‚’åŒæ™‚å‡¦ç†å¯èƒ½</li>
                        </ol>
                        <div class="mt-3 pt-3 border-t border-blue-200">
                            <p class="text-xs font-semibold text-slate-700 mb-1">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ:</p>
                            <ul class="text-xs text-slate-600 space-y-0.5">
                                <li>â€¢ Ctrl+O: ç”»åƒã‚’é–‹ã</li>
                                <li>â€¢ Ctrl+S: ä¿å­˜</li>
                                <li>â€¢ Ctrl+I: ãƒªã‚µã‚¤ã‚º</li>
                                <li>â€¢ Ctrl+R: ãƒªã‚»ãƒƒãƒˆ</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Terms Section -->
                    <div class="mt-4 p-4 bg-amber-50 rounded-lg">
                        <h3 class="text-md font-bold text-slate-800 mb-2">åˆ©ç”¨è¦ç´„</h3>
                        <p class="text-sm text-slate-700">
                            ã“ã®ãƒ„ãƒ¼ãƒ«ã¯è‡ªç”±ã«ã”åˆ©ç”¨ã„ãŸã ã‘ã¾ã™ï¼åˆ¶é™ã¯è¨­ã‘ã¾ã›ã‚“ã€‚<br>
                            ãŸã ã—ã€èª­ã¿è¾¼ã¾ã›ãŸç”»åƒã«åˆ©ç”¨è¦ç´„ç­‰ãŒã‚ã‚‹å ´åˆã¯ãã¡ã‚‰ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚<br>
                            <strong>â€»æœ¬ãƒ„ãƒ¼ãƒ«ã®åˆ©ç”¨ã«ã‚ˆã‚‹ä¸€åˆ‡ã®è²¬ä»»ã¯è² ã„ã‹ã­ã¾ã™ã€‚</strong>
                        </p>
                    </div>
                </div>

                <!-- Image Preview Column -->
                <div class="lg:col-span-2">
                    <div
                        id="image-drop-zone"
                        class="placeholder rounded-xl bg-white h-full flex items-center justify-center min-h-[400px]"
                    >
                        <div
                            id="placeholder-content"
                            class="text-center text-slate-500"
                        >
                            <svg
                                class="mx-auto h-16 w-16"
                                stroke="currentColor"
                                fill="none"
                                viewBox="0 0 48 48"
                                aria-hidden="true"
                            >
                                <path
                                    d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8"
                                    stroke-width="2"
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                ></path>
                            </svg>
                            <p class="mt-4">ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</p>
                            <p class="text-sm">ã¾ãŸã¯[é–‹ã]ã‚’ã‚¯ãƒªãƒƒã‚¯</p>
                        </div>
                        <div
                            id="preview-container"
                            class="hidden w-full h-full p-2 relative"
                        >
                            <img
                                id="preview-image"
                                class="max-w-full max-h-full object-contain mx-auto"
                                draggable="true"
                            />
                            <div
                                id="output-meta"
                                class="hidden absolute bottom-3 right-3 bg-slate-900/70 text-white text-xs px-2 py-1 rounded shadow"
                            >
                                å‡ºåŠ›ã‚µã‚¤ã‚º:
                                <span id="output-dimensions">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hidden elements for processing -->
        <img id="original-image" class="hidden" />
        <canvas id="processing-canvas" class="hidden"></canvas>
        <input type="file" id="file-input" class="hidden" accept="image/*" />
        <input type="file" id="batch-file-input" class="hidden" accept="image/*" multiple />

        <!-- Progress Bar Modal -->
        <div id="progress-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                <h3 class="text-lg font-bold text-slate-800 mb-4">å‡¦ç†ä¸­...</h3>
                <div class="w-full bg-slate-200 rounded-full h-4 mb-2">
                    <div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <p id="progress-text" class="text-sm text-slate-600 text-center">0 / 0</p>
            </div>
        </div>

        <script>
            document.addEventListener("DOMContentLoaded", () => {
                const imageDropZone =
                    document.getElementById("image-drop-zone");
                const placeholderContent = document.getElementById(
                    "placeholder-content",
                );
                const previewContainer =
                    document.getElementById("preview-container");
                const previewImage = document.getElementById("preview-image");
                const fileInput = document.getElementById("file-input");
                const originalImage = document.getElementById("original-image");
                const processingCanvas =
                    document.getElementById("processing-canvas");
                const filterListEl = document.getElementById("filter-list");
                const noFiltersMsg = document.getElementById("no-filters-msg");
                const outputMeta = document.getElementById("output-meta");
                const outputDimensionsEl = document.getElementById("output-dimensions");

                const uploadBtn = document.getElementById("upload-btn");
                const batchUploadBtn = document.getElementById("batch-upload-btn");
                const batchFileInput = document.getElementById("batch-file-input");
                const saveBtn = document.getElementById("save-btn");
                const compressBtn = document.getElementById("compress-btn");
                const compressMenu = document.getElementById("compress-menu");
                const resizeBtn = document.getElementById("resize-btn");
                const resetBtn = document.getElementById("reset-btn");
                const progressModal = document.getElementById("progress-modal");
                const progressBar = document.getElementById("progress-bar");
                const progressText = document.getElementById("progress-text");

                const filterTabsContainer =
                    document.getElementById("filter-tabs");
                const tabPanels = document.querySelectorAll(".tab-panel");

                let filters = [];
                let imageLoaded = false;
                let renderTimeout = null;
                let isBatchProcessing = false;

                const EXPORT_FORMATS = {
                    ".jpg": { ext: ".jpg", mime: "image/jpeg", quality: 0.92 },
                    ".jpeg": { ext: ".jpg", mime: "image/jpeg", quality: 0.92 },
                    ".png": { ext: ".png", mime: "image/png" },
                    ".webp": { ext: ".webp", mime: "image/webp", quality: 0.92 }
                };

                const normalizeExtension = (ext = "") =>
                    ext.startsWith(".") ? ext.toLowerCase() : `.${ext.toLowerCase()}`;

                const pickExportFormat = (ext = "", mime = "") => {
                    const normalizedExt = normalizeExtension(ext);
                    if (EXPORT_FORMATS[normalizedExt]) {
                        return EXPORT_FORMATS[normalizedExt];
                    }
                    const lowerMime = mime.toLowerCase();
                    const match = Object.values(EXPORT_FORMATS).find(
                        (format) => format.mime === lowerMime,
                    );
                    return match || EXPORT_FORMATS[".png"];
                };

                const splitFileName = (fileName = "") => {
                    const match = fileName.match(/^(.*?)(\.[^.]+)?$/);
                    return {
                        base: match?.[1] ?? "image",
                        ext: match?.[2] ?? "",
                    };
                };

                const stripFilteredSuffix = (baseName = "") =>
                    baseName.replace(/_filtered$/i, "") || "image";

                const buildFilteredFileName = (baseName, extension) => {
                    const sanitizedBase = stripFilteredSuffix(baseName);
                    return `${sanitizedBase}_filtered${extension}`;
                };

                const updateCurrentFileMetadata = (fileName, mimeType = "") => {
                    const { base, ext } = splitFileName(fileName);
                    currentExportFormat = pickExportFormat(ext, mimeType);
                    currentFileBaseName = stripFilteredSuffix(base);
                    currentFileName = buildFilteredFileName(
                        currentFileBaseName,
                        currentExportFormat.ext,
                    );
                };

                const resolveExportForFile = (file) => {
                    const { base, ext } = splitFileName(file.name);
                    const format = pickExportFormat(ext, file.type || "");
                    const outputName = buildFilteredFileName(base, format.ext);
                    return { format, outputName };
                };

                const parseHexColor = (hex, fallback = { r: 255, g: 255, b: 255 }) => {
                    if (typeof hex !== "string") return fallback;
                    const cleaned = hex.replace("#", "");
                    if (cleaned.length === 3) {
                        const r = parseInt(cleaned[0] + cleaned[0], 16);
                        const g = parseInt(cleaned[1] + cleaned[1], 16);
                        const b = parseInt(cleaned[2] + cleaned[2], 16);
                        return { r, g, b };
                    }
                    if (cleaned.length === 6) {
                        const r = parseInt(cleaned.slice(0, 2), 16);
                        const g = parseInt(cleaned.slice(2, 4), 16);
                        const b = parseInt(cleaned.slice(4, 6), 16);
                        return { r, g, b };
                    }
                    return fallback;
                };

                const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
                const MAX_RESIZE_DIMENSION = 8192;
                const ALLOWED_COLOR_LEVELS = Object.freeze([2, 4, 8, 16, 32, 64, 128, 256]);
                const MAX_COLOR_QUANT_SAMPLES = 12000;

                const getFilterParamValue = (filter, key, fallback = null) =>
                    filter.params?.find((p) => p.key === key)?.value ?? fallback;

                const toPositiveInt = (value, fallback) => {
                    const parsed = parseInt(value, 10);
                    return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;
                };

                const resolveResizeDimensions = (filter, baseWidth, baseHeight) => {
                    if (!filter) {
                        return { width: baseWidth, height: baseHeight };
                    }

                    const mode = getFilterParamValue(filter, "mode", "percent");
                    const keepRatio = getFilterParamValue(filter, "keepRatio", "true") !== "false";
                    const aspectRatio = baseWidth / baseHeight || 1;

                    let targetWidth = baseWidth;
                    let targetHeight = baseHeight;

                    if (mode === "percent") {
                        const percent = Math.max(1, parseFloat(filter.value) || 100);
                        const scale = clamp(percent / 100, 0.01, 8);
                        targetWidth = baseWidth * scale;
                        targetHeight = baseHeight * scale;
                    } else if (mode === "width") {
                        const widthParam = toPositiveInt(getFilterParamValue(filter, "width", baseWidth), baseWidth);
                        targetWidth = widthParam;
                        if (keepRatio) {
                            targetHeight = widthParam / aspectRatio;
                        } else {
                            targetHeight = toPositiveInt(getFilterParamValue(filter, "height", baseHeight), baseHeight);
                        }
                    } else if (mode === "height") {
                        const heightParam = toPositiveInt(getFilterParamValue(filter, "height", baseHeight), baseHeight);
                        targetHeight = heightParam;
                        if (keepRatio) {
                            targetWidth = heightParam * aspectRatio;
                        } else {
                            targetWidth = toPositiveInt(getFilterParamValue(filter, "width", baseWidth), baseWidth);
                        }
                    } else if (mode === "both") {
                        targetWidth = toPositiveInt(getFilterParamValue(filter, "width", baseWidth), baseWidth);
                        targetHeight = toPositiveInt(getFilterParamValue(filter, "height", baseHeight), baseHeight);
                    }

                    const clampedWidth = clamp(Math.round(targetWidth), 1, MAX_RESIZE_DIMENSION);
                    const clampedHeight = clamp(Math.round(targetHeight), 1, MAX_RESIZE_DIMENSION);
                    return { width: clampedWidth, height: clampedHeight };
                };

                const splitFiltersForResize = (activeFilters, baseWidth, baseHeight) => {
                    let resizeFilter = null;
                    const remaining = [];

                    activeFilters.forEach((filter) => {
                        if (filter.type === "resize") {
                            resizeFilter = filter;
                        } else {
                            remaining.push(filter);
                        }
                    });

                    const { width: targetWidth, height: targetHeight } = resolveResizeDimensions(
                        resizeFilter,
                        baseWidth,
                        baseHeight,
                    );

                    return { resizeFilter, remaining, targetWidth, targetHeight };
                };

                const updateOutputDimensions = (width, height) => {
                    if (!outputMeta || !outputDimensionsEl) return;
                    outputMeta.classList.remove("hidden");
                    outputDimensionsEl.textContent = `${width} Ã— ${height}px`;
                };

                const snapToAllowedColorLevel = (value = 16) => {
                    const numeric = Number.isFinite(value) ? value : 16;
                    if (numeric <= ALLOWED_COLOR_LEVELS[0]) {
                        return ALLOWED_COLOR_LEVELS[0];
                    }
                    if (numeric >= ALLOWED_COLOR_LEVELS[ALLOWED_COLOR_LEVELS.length - 1]) {
                        return ALLOWED_COLOR_LEVELS[ALLOWED_COLOR_LEVELS.length - 1];
                    }
                    let closest = ALLOWED_COLOR_LEVELS[0];
                    let minDiff = Math.abs(numeric - closest);
                    for (let i = 1; i < ALLOWED_COLOR_LEVELS.length; i++) {
                        const candidate = ALLOWED_COLOR_LEVELS[i];
                        const diff = Math.abs(numeric - candidate);
                        if (diff < minDiff) {
                            closest = candidate;
                            minDiff = diff;
                        }
                    }
                    return closest;
                };

                const sampleColorsForQuantization = (imageData, levels) => {
                    const { data } = imageData;
                    const totalPixels = data.length / 4;
                    const baseTarget = Math.max(levels * 16, 1024);
                    const targetSamples = Math.min(
                        MAX_COLOR_QUANT_SAMPLES,
                        Math.max(baseTarget, 64),
                    );
                    const step = Math.max(1, Math.floor(totalPixels / targetSamples));
                    const samples = [];
                    const seen = new Set();
                    for (let i = 0; i < data.length; i += step * 4) {
                        const alpha = data[i + 3];
                        if (alpha < 1) continue;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const key = (r << 16) | (g << 8) | b;
                        if (seen.has(key)) continue;
                        seen.add(key);
                        samples.push([r, g, b]);
                        if (samples.length >= targetSamples) break;
                    }
                    if (samples.length === 0) {
                        samples.push([0, 0, 0]);
                    }
                    return samples;
                };

                const channelRange = (bucket, channelIndex) => {
                    let min = 255;
                    let max = 0;
                    for (let i = 0; i < bucket.length; i++) {
                        const value = bucket[i][channelIndex];
                        if (value < min) min = value;
                        if (value > max) max = value;
                    }
                    return { min, max, delta: max - min };
                };

                const bucketRange = (bucket) => {
                    const rRange = channelRange(bucket, 0).delta;
                    const gRange = channelRange(bucket, 1).delta;
                    const bRange = channelRange(bucket, 2).delta;
                    return Math.max(rRange, gRange, bRange);
                };

                const splitColorBucket = (bucket) => {
                    if (bucket.length <= 1) {
                        return [bucket.slice(), []];
                    }
                    const ranges = [
                        { channel: 0, ...channelRange(bucket, 0) },
                        { channel: 1, ...channelRange(bucket, 1) },
                        { channel: 2, ...channelRange(bucket, 2) },
                    ].sort((a, b) => b.delta - a.delta);

                    const target = ranges[0];
                    if (!target || target.delta === 0) {
                        return [bucket.slice(), []];
                    }

                    const channel = target.channel;
                    const sorted = bucket.slice().sort(
                        (a, b) => a[channel] - b[channel],
                    );
                    const mid = Math.floor(sorted.length / 2);
                    const left = sorted.slice(0, mid);
                    const right = sorted.slice(mid);

                    if (!left.length || !right.length) {
                        return [bucket.slice(), []];
                    }

                    return [left, right];
                };

                const buildPaletteMedianCut = (imageData, requestedLevels) => {
                    const snappedLevels = snapToAllowedColorLevel(requestedLevels);
                    const samples = sampleColorsForQuantization(imageData, snappedLevels);
                    const target = Math.min(snappedLevels, samples.length);

                    if (target <= 1) {
                        const [firstColor] = samples;
                        return [[firstColor[0], firstColor[1], firstColor[2]]];
                    }

                    let buckets = [samples];

                    while (buckets.length < target) {
                        buckets.sort((a, b) => bucketRange(b) - bucketRange(a));
                        const bucket = buckets.shift();
                        if (!bucket) break;
                        if (bucket.length <= 1) {
                            buckets.push(bucket);
                            break;
                        }
                        const [left, right] = splitColorBucket(bucket);
                        if (!right.length) {
                            buckets.push(bucket);
                            break;
                        }
                        buckets.push(left, right);
                    }

                    if (buckets.length > target) {
                        buckets = buckets.slice(0, target);
                    }

                    const palette = buckets.map((bucket) => {
                        let r = 0, g = 0, b = 0;
                        const len = bucket.length || 1;
                        for (let i = 0; i < len; i++) {
                            r += bucket[i][0];
                            g += bucket[i][1];
                            b += bucket[i][2];
                        }
                        return [
                            Math.round(r / len),
                            Math.round(g / len),
                            Math.round(b / len),
                        ];
                    });

                    while (palette.length < target) {
                        palette.push(palette[palette.length - 1]);
                    }

                    return palette;
                };

                const findNearestPaletteColor = (palette, r, g, b) => {
                    let closest = palette[0];
                    let minDist = Infinity;
                    for (let i = 0; i < palette.length; i++) {
                        const pr = palette[i][0];
                        const pg = palette[i][1];
                        const pb = palette[i][2];
                        const dr = r - pr;
                        const dg = g - pg;
                        const db = b - pb;
                        const dist = dr * dr + dg * dg + db * db;
                        if (dist < minDist) {
                            minDist = dist;
                            closest = palette[i];
                            if (dist === 0) break;
                        }
                    }
                    return closest;
                };

                const applyExactColorQuantization = (imageData, levels, ditherStrength = 0) => {
                    const snappedLevels = snapToAllowedColorLevel(levels);
                    const palette = buildPaletteMedianCut(imageData, snappedLevels);
                    if (!palette.length) {
                        return 0;
                    }

                    const { data, width, height } = imageData;
                    const strength = clamp(ditherStrength, 0, 1);
                    const cache = new Map();
                    const getNearestColor = (r, g, b) => {
                        const key =
                            ((Math.round(r) & 0xff) << 16) |
                            ((Math.round(g) & 0xff) << 8) |
                            (Math.round(b) & 0xff);
                        if (cache.has(key)) {
                            return cache.get(key);
                        }
                        const nearest = findNearestPaletteColor(palette, r, g, b);
                        cache.set(key, nearest);
                        return nearest;
                    };

                    if (strength > 0) {
                        const floatData = new Float32Array(data.length);
                        for (let i = 0; i < data.length; i++) {
                            floatData[i] = data[i];
                        }
                        const weights = [
                            { dx: 1, dy: 0, weight: 7 / 16 },
                            { dx: -1, dy: 1, weight: 3 / 16 },
                            { dx: 0, dy: 1, weight: 5 / 16 },
                            { dx: 1, dy: 1, weight: 1 / 16 },
                        ];

                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const idx = (y * width + x) * 4;
                                const alpha = data[idx + 3];
                                if (alpha < 1) continue;

                                const oldR = floatData[idx];
                                const oldG = floatData[idx + 1];
                                const oldB = floatData[idx + 2];
                                const nearest = getNearestColor(oldR, oldG, oldB);

                                data[idx] = nearest[0];
                                data[idx + 1] = nearest[1];
                                data[idx + 2] = nearest[2];

                                floatData[idx] = nearest[0];
                                floatData[idx + 1] = nearest[1];
                                floatData[idx + 2] = nearest[2];

                                const errR = (oldR - nearest[0]) * strength;
                                const errG = (oldG - nearest[1]) * strength;
                                const errB = (oldB - nearest[2]) * strength;

                                for (let w = 0; w < weights.length; w++) {
                                    const { dx, dy, weight } = weights[w];
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
                                        continue;
                                    }
                                    const nIdx = (ny * width + nx) * 4;
                                    floatData[nIdx] = clamp(floatData[nIdx] + errR * weight, 0, 255);
                                    floatData[nIdx + 1] = clamp(floatData[nIdx + 1] + errG * weight, 0, 255);
                                    floatData[nIdx + 2] = clamp(floatData[nIdx + 2] + errB * weight, 0, 255);
                                }
                            }
                        }
                    } else {
                        for (let i = 0; i < data.length; i += 4) {
                            const alpha = data[i + 3];
                            if (alpha < 1) continue;
                            const nearest = getNearestColor(data[i], data[i + 1], data[i + 2]);
                            data[i] = nearest[0];
                            data[i + 1] = nearest[1];
                            data[i + 2] = nearest[2];
                        }
                    }

                    return palette.length;
                };

                let currentExportFormat = EXPORT_FORMATS[".png"];
                let currentFileBaseName = "image";
                let currentFileName = buildFilteredFileName(
                    currentFileBaseName,
                    currentExportFormat.ext,
                );

                // ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—ã®ãƒªã‚¹ãƒˆï¼ˆä¸€å…ƒç®¡ç†ï¼‰
                const CUSTOM_FILTER_TYPES = [
                    "threshold", "pixelate", "dither", "posterize", "colorquant", "red", "green", "blue",
                    "noise", "vignette", "solarize", "sharpen", "exposure", "emboss",
                    "temperature", "vibrance", "gamma", "colorize", "duotone",
                    "tonecurve", "edge", "chromatic", "scanlines", "haze", "bloom"
                ];
                const createFilterPresets = () => ({
                        resize: {
                            label: "ãƒªã‚µã‚¤ã‚º",
                            min: 10,
                            max: 400,
                            value: 100,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "mode",
                                    label: "æ–¹å¼",
                                    type: "select",
                                    value: "percent",
                                    options: [
                                        { value: "percent", label: "%æŒ‡å®š" },
                                        { value: "width", label: "æ¨ªå¹…æŒ‡å®š" },
                                        { value: "height", label: "ç¸¦å¹…æŒ‡å®š" },
                                        { value: "both", label: "å¹…+é«˜ã•" }
                                    ]
                                },
                                {
                                    key: "width",
                                    label: "æ¨ªå¹…",
                                    type: "number",
                                    value: 512,
                                    min: 1,
                                    max: 8192,
                                    unitLabel: " px"
                                },
                                {
                                    key: "height",
                                    label: "ç¸¦å¹…",
                                    type: "number",
                                    value: 512,
                                    min: 1,
                                    max: 8192,
                                    unitLabel: " px"
                                },
                                {
                                    key: "keepRatio",
                                    label: "æ¯”ç‡ç¶­æŒ",
                                    type: "select",
                                    value: "true",
                                    options: [
                                        { value: "true", label: "ç¶­æŒã™ã‚‹" },
                                        { value: "false", label: "ç¶­æŒã—ãªã„" }
                                    ]
                                }
                            ]
                        },
                        brightness: {
                            label: "æ˜åº¦",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        contrast: {
                            label: "ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        saturate: {
                            label: "å½©åº¦",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        exposure: {
                            label: "éœ²å‡º",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        opacity: {
                            label: "ä¸é€æ˜åº¦",
                            min: 0,
                            max: 100,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        grayscale: {
                            label: "ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "%",
                            enabled: true,
                        },
                        sepia: {
                            label: "ã‚»ãƒ”ã‚¢",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "%",
                            enabled: true,
                        },
                        invert: {
                            label: "éšèª¿ã®åè»¢",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "%",
                            enabled: true,
                        },
                        blur: {
                            label: "ã¼ã‹ã—",
                            min: 0,
                            max: 20,
                            value: 5,
                            unit: "px",
                            enabled: true,
                            params: [
                                {
                                    key: "direction",
                                    label: "æ–¹å‘",
                                    type: "select",
                                    value: "all",
                                    options: [
                                        { value: "all", label: "å…¨ä½“" },
                                        { value: "horizontal", label: "æ¨ªæ–¹å‘" },
                                        { value: "vertical", label: "ç¸¦æ–¹å‘" }
                                    ]
                                }
                            ]
                        },
                        "hue-rotate": {
                            label: "è‰²ç›¸å›è»¢",
                            min: 0,
                            max: 360,
                            value: 180,
                            unit: "deg",
                            enabled: true,
                        },
                        red: {
                            label: "èµ¤ãƒãƒ£ãƒ³ãƒãƒ«",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        green: {
                            label: "ç·‘ãƒãƒ£ãƒ³ãƒãƒ«",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        blue: {
                            label: "é’ãƒãƒ£ãƒ³ãƒãƒ«",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        noise: {
                            label: "ãƒã‚¤ã‚º",
                            min: 0,
                            max: 100,
                            value: 20,
                            unit: "",
                            enabled: true,
                        },
                        vignette: {
                            label: "ãƒ“ãƒãƒƒãƒˆ",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "shape",
                                    label: "å½¢çŠ¶",
                                    type: "select",
                                    value: "circle",
                                    options: [
                                        { value: "circle", label: "å††å½¢" },
                                        { value: "square", label: "å››è§’å½¢" }
                                    ]
                                }
                            ]
                        },
                        threshold: {
                            label: "äºŒå€¤åŒ–",
                            min: 0,
                            max: 255,
                            value: 128,
                            unit: "",
                            enabled: true,
                        },
                        pixelate: {
                            label: "ãƒ”ã‚¯ã‚»ãƒ«åŒ–",
                            min: 1,
                            max: 50,
                            value: 10,
                            unit: "px",
                            enabled: true,
                        },
                        dither: {
                            label: "ãƒ¬ãƒˆãƒ­ãƒ‰ãƒƒãƒˆ",
                            min: 0,
                            max: 100,
                            value: 100,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "palette",
                                    label: "ãƒ‘ãƒ¬ãƒƒãƒˆ",
                                    type: "select",
                                    value: "original",
                                    options: [
                                        { value: "original", label: "ã‚«ãƒ©ãƒ¼ä¿æŒ" },
                                        { value: "gb", label: "GBã‚°ãƒªãƒ¼ãƒ³" },
                                        { value: "mono", label: "ãƒ¢ãƒã‚¯ãƒ­" },
                                        { value: "sunset", label: "ã‚µãƒ³ã‚»ãƒƒãƒˆ" }
                                    ]
                                },
                                {
                                    key: "pattern",
                                    label: "ãƒ‘ã‚¿ãƒ¼ãƒ³",
                                    type: "select",
                                    value: "mesh",
                                    options: [
                                        { value: "mesh", label: "ã‚¢ãƒŸã‚¢ãƒŸ" },
                                        { value: "stagger", label: "ãšã‚‰ã—æ ¼å­" },
                                        { value: "diagonal", label: "ãªãªã‚" }
                                    ]
                                },
                                {
                                    key: "scale",
                                    label: "ç²’åº¦",
                                    type: "range",
                                    value: 1,
                                    min: 1,
                                    max: 4,
                                    step: 1,
                                    unitLabel: " å€"
                                }
                            ]
                        },
                        colorquant: {
                            label: "ã‚«ãƒ©ãƒ¼æ•°åœ§ç¸®",
                            min: 2,
                            max: 256,
                            value: 16,
                            step: 1,
                            unit: "",
                            unitLabel: " è‰²",
                            enabled: true,
                            params: [
                                {
                                    key: "levels",
                                    label: "è‰²æ•°",
                                    type: "select",
                                    value: "16",
                                    options: [
                                        { value: "2", label: "2è‰²" },
                                        { value: "4", label: "4è‰²" },
                                        { value: "8", label: "8è‰²" },
                                        { value: "16", label: "16è‰²" },
                                        { value: "32", label: "32è‰²" },
                                        { value: "64", label: "64è‰²" },
                                        { value: "128", label: "128è‰²" },
                                        { value: "256", label: "256è‰²" }
                                    ]
                                },
                                {
                                    key: "ditherStrength",
                                    label: "ãƒ‡ã‚£ã‚¶ãƒ¼",
                                    type: "range",
                                    value: 20,
                                    min: 0,
                                    max: 100,
                                    step: 5,
                                    unitLabel: "%"
                                }
                            ]
                        },
                        posterize: {
                            label: "ãƒã‚¹ã‚¿ãƒ©ã‚¤ã‚º",
                            min: 2,
                            max: 32,
                            value: 8,
                            unit: "",
                            unitLabel: " æ®µéš",
                            enabled: true,
                            params: [
                                {
                                    key: "baseColors",
                                    label: "åŸºæº–è‰²",
                                    type: "select",
                                    value: "none",
                                    options: [
                                        { value: "none", label: "ãªã—" },
                                        { value: "red", label: "èµ¤ç³»" },
                                        { value: "green", label: "ç·‘ç³»" },
                                        { value: "blue", label: "é’ç³»" },
                                        { value: "warm", label: "æš–è‰²ç³»" },
                                        { value: "cool", label: "å¯’è‰²ç³»" },
                                        { value: "custom", label: "ã‚«ã‚¹ã‚¿ãƒ " }
                                    ]
                                },
                                {
                                    key: "customColor",
                                    label: "ã‚«ã‚¹ã‚¿ãƒ è‰²",
                                    type: "color",
                                    value: "#ff0000"
                                }
                            ]
                        },
                        sharpen: {
                            label: "ã‚·ãƒ£ãƒ¼ãƒ—",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "%",
                            enabled: true,
                        },
                        emboss: {
                            label: "ã‚¨ãƒ³ãƒœã‚¹",
                            min: 0,
                            max: 100,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        solarize: {
                            label: "ã‚½ãƒ©ãƒªã‚¼ãƒ¼ã‚·ãƒ§ãƒ³",
                            min: 0,
                            max: 255,
                            value: 128,
                            unit: "",
                            enabled: true,
                        },
                        temperature: {
                            label: "è‰²æ¸©åº¦",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "",
                            enabled: true,
                        },
                        vibrance: {
                            label: "è‡ªç„¶ãªå½©åº¦",
                            min: 0,
                            max: 200,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        gamma: {
                            label: "ã‚¬ãƒ³ãƒ",
                            min: 10,
                            max: 300,
                            value: 100,
                            unit: "%",
                            enabled: true,
                        },
                        colorize: {
                            label: "ç€è‰²",
                            min: 0,
                            max: 360,
                            value: 180,
                            unit: "Â°",
                            enabled: true,
                        },
                        duotone: {
                            label: "2éšèª¿",
                            min: 0,
                            max: 100,
                            value: 50,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "shadowColor",
                                    label: "ã‚·ãƒ£ãƒ‰ã‚¦è‰²",
                                    type: "color",
                                    value: "#1a1a4d"
                                },
                                {
                                    key: "highlightColor",
                                    label: "ãƒã‚¤ãƒ©ã‚¤ãƒˆè‰²",
                                    type: "color",
                                    value: "#ff6b9d"
                                }
                            ]
                        },
                        tonecurve: {
                            label: "ãƒˆãƒ¼ãƒ³ã‚«ãƒ¼ãƒ–",
                            min: 0,
                            max: 100,
                            value: 100,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "curveType",
                                    label: "ã‚«ãƒ¼ãƒ–ç¨®é¡",
                                    type: "select",
                                    value: "s",
                                    options: [
                                        { value: "s", label: "Sã‚«ãƒ¼ãƒ– (ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆâ†‘)" },
                                        { value: "inverse-s", label: "é€†Sã‚«ãƒ¼ãƒ– (ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆâ†“)" },
                                        { value: "brighten", label: "æ˜ã‚‹ã" },
                                        { value: "darken", label: "æš—ã" }
                                    ]
                                }
                            ]
                        },
                        edge: {
                            label: "è¼ªéƒ­ç·šæŠ½å‡º",
                            min: 0,
                            max: 100,
                            value: 100,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "edgeMode",
                                    label: "ãƒ¢ãƒ¼ãƒ‰",
                                    type: "select",
                                    value: "normal",
                                    options: [
                                        { value: "normal", label: "é€šå¸¸" },
                                        { value: "invert", label: "åè»¢" }
                                    ]
                                }
                            ]
                        },
                        chromatic: {
                            label: "è‰²åå·®",
                            min: 0,
                            max: 50,
                            value: 8,
                            unit: "px",
                            enabled: true,
                            params: [
                                {
                                    key: "direction",
                                    label: "æ–¹å‘",
                                    type: "select",
                                    value: "horizontal",
                                    options: [
                                        { value: "horizontal", label: "æ¨ª" },
                                        { value: "vertical", label: "ç¸¦" },
                                        { value: "diagonal", label: "æ–œã‚" }
                                    ]
                                }
                            ]
                        },
                        scanlines: {
                            label: "ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³",
                            min: 0,
                            max: 100,
                            value: 40,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "spacing",
                                    label: "é–“éš”",
                                    type: "range",
                                    value: 6,
                                    min: 2,
                                    max: 24,
                                    step: 1,
                                    unitLabel: " px"
                                },
                                {
                                    key: "thickness",
                                    label: "å¤ªã•",
                                    type: "range",
                                    value: 2,
                                    min: 1,
                                    max: 8,
                                    step: 1,
                                    unitLabel: " px"
                                }
                            ]
                        },
                        bloom: {
                            label: "ãƒ–ãƒ«ãƒ¼ãƒ ",
                            min: 0,
                            max: 255,
                            value: 200,
                            unit: "",
                            enabled: true,
                            params: [
                                {
                                    key: "intensity",
                                    label: "å¼·åº¦",
                                    type: "range",
                                    min: 0,
                                    max: 200,
                                    value: 100,
                                    unit: "%"
                                }
                            ]
                        },
                        haze: {
                            label: "éœ",
                            min: 0,
                            max: 100,
                            value: 35,
                            unit: "%",
                            enabled: true,
                            params: [
                                {
                                    key: "tint",
                                    label: "è‰²å‘³",
                                    type: "color",
                                    value: "#f0f6ff"
                                }
                            ]
                        },
                                    });

                const instantiateFilter = (type, overrides = {}) => {
                    const presets = createFilterPresets();
                    const base = presets[type];
                    if (!base) {
                        return null;
                    }
                    const baseConfig = { type, ...base };
                    const cloned = typeof structuredClone === "function"
                        ? structuredClone(baseConfig)
                        : JSON.parse(JSON.stringify(baseConfig));
                    if (typeof overrides.value !== "undefined") {
                        cloned.value = overrides.value;
                    }
                    if (typeof overrides.enabled !== "undefined") {
                        cloned.enabled = overrides.enabled;
                    }
                    if (Array.isArray(overrides.params) && cloned.params) {
                        overrides.params.forEach((overrideParam) => {
                            const targetParam = cloned.params.find((p) => p.key === overrideParam.key);
                            if (targetParam) {
                                targetParam.value = overrideParam.value;
                            }
                        });
                    }
                    return cloned;
                };


                // ç•³ã¿è¾¼ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨é–¢æ•°ï¼ˆå…±é€šï¼‰
                const applyConvolution = (src, dst, kernel, blend, offset = 0) => {
                    const srcData = src.data;
                    const dstData = dst.data;
                    const width = src.width;
                    const height = src.height;
                    const kernelSize = kernel.length;
                    const halfKernel = Math.floor(kernelSize / 2);
                    const originalData = new Uint8ClampedArray(srcData);

                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            let r = 0, g = 0, b = 0;
                            for (let ky = 0; ky < kernelSize; ky++) {
                                for (let kx = 0; kx < kernelSize; kx++) {
                                    const scx = Math.min(width - 1, Math.max(0, x + kx - halfKernel));
                                    const scy = Math.min(height - 1, Math.max(0, y + ky - halfKernel));
                                    const srcI = (scy * width + scx) * 4;
                                    const weight = kernel[ky][kx];
                                    r += srcData[srcI] * weight;
                                    g += srcData[srcI + 1] * weight;
                                    b += srcData[srcI + 2] * weight;
                                }
                            }
                            const dstI = (y * width + x) * 4;
                            dstData[dstI] = originalData[dstI] * (1 - blend) + (r + offset) * blend;
                            dstData[dstI + 1] = originalData[dstI + 1] * (1 - blend) + (g + offset) * blend;
                            dstData[dstI + 2] = originalData[dstI + 2] * (1 - blend) + (b + offset) * blend;
                        }
                    }
                };

                const applyDirectionalBlurToImageData = (imageData, radius, direction) => {
                    const size = Math.round(radius);
                    if (size <= 0) return;

                    const { data, width, height } = imageData;
                    const original = new Uint8ClampedArray(data);

                    if (direction === "vertical") {
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                let r = 0, g = 0, b = 0;
                                let count = 0;
                                for (let dy = -size; dy <= size; dy++) {
                                    const ny = clamp(y + dy, 0, height - 1);
                                    const idx = (ny * width + x) * 4;
                                    r += original[idx];
                                    g += original[idx + 1];
                                    b += original[idx + 2];
                                    count++;
                                }
                                const dest = (y * width + x) * 4;
                                data[dest] = r / count;
                                data[dest + 1] = g / count;
                                data[dest + 2] = b / count;
                            }
                        }
                    } else {
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                let r = 0, g = 0, b = 0;
                                let count = 0;
                                for (let dx = -size; dx <= size; dx++) {
                                    const nx = clamp(x + dx, 0, width - 1);
                                    const idx = (y * width + nx) * 4;
                                    r += original[idx];
                                    g += original[idx + 1];
                                    b += original[idx + 2];
                                    count++;
                                }
                                const dest = (y * width + x) * 4;
                                data[dest] = r / count;
                                data[dest + 1] = g / count;
                                data[dest + 2] = b / count;
                            }
                        }
                    }
                };

                // ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨é–¢æ•°ï¼ˆå…±é€šï¼‰
                const applyCustomFilterToImageData = (imageData, filter, w, h) => {
                    const data = imageData.data;

                    if (filter.type === "threshold") {
                        const v = filter.value;
                        for (let i = 0; i < data.length; i += 4) {
                            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const color = avg < v ? 0 : 255;
                            data[i] = data[i + 1] = data[i + 2] = color;
                        }
                    } else if (filter.type === "posterize") {
                        const levels = filter.value;
                        const baseColors = filter.params?.[0]?.value || "none";
                        const customColor = filter.params?.[1]?.value || "#ff0000";
                        if (levels > 1) {
                            const step = 255 / (levels - 1);
                            let baseR = 0, baseG = 0, baseB = 0;
                            if (baseColors === "custom") {
                                const hex = customColor.replace('#', '');
                                baseR = parseInt(hex.substr(0, 2), 16);
                                baseG = parseInt(hex.substr(2, 2), 16);
                                baseB = parseInt(hex.substr(4, 2), 16);
                            }
                            for (let i = 0; i < data.length; i += 4) {
                                let r = Math.round(data[i] / step) * step;
                                let g = Math.round(data[i + 1] / step) * step;
                                let b = Math.round(data[i + 2] / step) * step;
                                if (baseColors === "red") {
                                    r = Math.min(255, r * 1.2);
                                    g *= 0.8;
                                    b *= 0.8;
                                } else if (baseColors === "green") {
                                    r *= 0.8;
                                    g = Math.min(255, g * 1.2);
                                    b *= 0.8;
                                } else if (baseColors === "blue") {
                                    r *= 0.8;
                                    g *= 0.8;
                                    b = Math.min(255, b * 1.2);
                                } else if (baseColors === "warm") {
                                    r = Math.min(255, r * 1.1);
                                    g = Math.min(255, g * 1.05);
                                    b *= 0.9;
                                } else if (baseColors === "cool") {
                                    r *= 0.9;
                                    g = Math.min(255, g * 1.05);
                                    b = Math.min(255, b * 1.1);
                                } else if (baseColors === "custom") {
                                    const gray = (r + g + b) / 3;
                                    const blend = 0.3;
                                    r = r * (1 - blend) + (baseR / 255) * gray * blend;
                                    g = g * (1 - blend) + (baseG / 255) * gray * blend;
                                    b = b * (1 - blend) + (baseB / 255) * gray * blend;
                                }
                                data[i] = r;
                                data[i + 1] = g;
                                data[i + 2] = b;
                            }
                        }
                    } else if (filter.type === "dither") {
                        const intensity = clamp(filter.value / 100, 0, 1);
                        if (intensity === 0) return;
                        const paletteKey = filter.params?.find((p) => p.key === "palette")?.value || "gb";
                        const patternKey = filter.params?.find((p) => p.key === "pattern")?.value || "mesh";
                        const scaleRaw = parseInt(filter.params?.find((p) => p.key === "scale")?.value ?? "1", 10);
                        const scale = clamp(Number.isFinite(scaleRaw) ? scaleRaw : 1, 1, 8);

                        const palettes = {
                            gb: ["#0f380f", "#306230", "#8bac0f", "#9bbc0f"],
                            mono: ["#111111", "#555555", "#aaaaaa", "#f5f5f5"],
                            sunset: ["#1c1b3a", "#64436a", "#d16c4b", "#ffd27f"]
                        };

                        const ditherPatterns = {
                            mesh: [
                                [0.10, 0.70, 0.18, 0.78],
                                [0.82, 0.32, 0.92, 0.42],
                                [0.22, 0.82, 0.12, 0.72],
                                [0.88, 0.38, 0.96, 0.48],
                            ],
                            stagger: [
                                [0.05, 0.55, 0.15, 0.65],
                                [0.35, 0.85, 0.45, 0.95],
                                [0.15, 0.65, 0.05, 0.55],
                                [0.45, 0.95, 0.35, 0.85],
                            ],
                            diagonal: [
                                [0.05, 0.20, 0.35, 0.50],
                                [0.20, 0.35, 0.50, 0.65],
                                [0.35, 0.50, 0.65, 0.80],
                                [0.50, 0.65, 0.80, 0.95],
                            ],
                        };

                        const pattern = ditherPatterns[patternKey] || ditherPatterns.mesh;
                        const patternHeight = pattern.length;
                        const patternWidth = pattern[0]?.length || 1;

                        if (paletteKey === "original") {
                            const maxAdjust = 160;
                            for (let y = 0; y < h; y++) {
                                for (let x = 0; x < w; x++) {
                                    const idx = (y * w + x) * 4;
                                    const r = data[idx];
                                    const g = data[idx + 1];
                                    const b = data[idx + 2];
                                    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
                                    const sampleX = Math.floor(x / scale);
                                    const sampleY = Math.floor(y / scale);
                                    const threshold = pattern[sampleY % patternHeight][sampleX % patternWidth];
                                    const diff = luminance - threshold;
                                    const adjust = clamp(diff * 255 * intensity * 0.9, -maxAdjust, maxAdjust);
                                    data[idx] = clamp(r + adjust, 0, 255);
                                    data[idx + 1] = clamp(g + adjust, 0, 255);
                                    data[idx + 2] = clamp(b + adjust, 0, 255);
                                }
                            }
                            return;
                        }

                        const paletteHex = palettes[paletteKey] || palettes.gb;
                        const palette = paletteHex.map((hex) => parseHexColor(hex));
                        const levels = palette.length - 1;
                        if (levels <= 0) return;

                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const idx = (y * w + x) * 4;
                                const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / (3 * 255);
                                const sampleX = Math.floor(x / scale);
                                const sampleY = Math.floor(y / scale);
                                const threshold = pattern[sampleY % patternHeight][sampleX % patternWidth];
                                const scaled = gray * levels;
                                const baseIndex = Math.max(0, Math.floor(scaled));
                                const frac = scaled - baseIndex;
                                const paletteIndex = Math.min(levels, baseIndex + (frac > threshold ? 1 : 0));
                                const color = palette[paletteIndex] || palette[palette.length - 1];

                                data[idx] = data[idx] * (1 - intensity) + color.r * intensity;
                                data[idx + 1] = data[idx + 1] * (1 - intensity) + color.g * intensity;
                                data[idx + 2] = data[idx + 2] * (1 - intensity) + color.b * intensity;
                            }
                        }
                    } else if (["red", "green", "blue"].includes(filter.type)) {
                        const channelIndex = { red: 0, green: 1, blue: 2 }[filter.type];
                        const mult = filter.value / 100;
                        for (let i = 0; i < data.length; i += 4) {
                            data[i + channelIndex] *= mult;
                        }
                    } else if (filter.type === "exposure") {
                        const mult = filter.value / 100;
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] *= mult;
                            data[i + 1] *= mult;
                            data[i + 2] *= mult;
                        }
                    } else if (filter.type === "noise") {
                        const amount = filter.value;
                        for (let i = 0; i < data.length; i += 4) {
                            const noise = (Math.random() - 0.5) * amount;
                            data[i] += noise;
                            data[i + 1] += noise;
                            data[i + 2] += noise;
                        }
                    } else if (filter.type === "vignette") {
                        const amount = filter.value / 100;
                        const shape = filter.params?.[0]?.value || "circle";
                        const centerX = w / 2;
                        const centerY = h / 2;
                        const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const i = (y * w + x) * 4;
                                const dx = x - centerX;
                                const dy = y - centerY;
                                let dist;
                                if (shape === "square") {
                                    dist = Math.max(Math.abs(dx), Math.abs(dy)) / Math.max(centerX, centerY);
                                } else {
                                    dist = Math.sqrt(dx * dx + dy * dy) / maxDist;
                                }
                                const darkness = Math.pow(dist, 2) * amount;
                                data[i] *= 1 - darkness;
                                data[i + 1] *= 1 - darkness;
                                data[i + 2] *= 1 - darkness;
                            }
                        }
                    } else if (filter.type === "solarize") {
                        const threshold = filter.value;
                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i] < threshold) data[i] = 255 - data[i];
                            if (data[i + 1] < threshold) data[i + 1] = 255 - data[i + 1];
                            if (data[i + 2] < threshold) data[i + 2] = 255 - data[i + 2];
                        }
                    } else if (filter.type === "sharpen" || filter.type === "emboss") {
                        const amount = filter.value / 100;
                        if (amount > 0) {
                            const kernel = filter.type === "sharpen"
                                ? [[0, -1, 0], [-1, 5, -1], [0, -1, 0]]
                                : [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]];
                            const offset = filter.type === "emboss" ? 128 : 0;
                            const sourceImageData = new ImageData(new Uint8ClampedArray(imageData.data), w, h);
                            applyConvolution(sourceImageData, imageData, kernel, amount, offset);
                        }
                    } else if (filter.type === 'temperature') {
                        const temp = (filter.value - 50) / 50;
                        for (let i = 0; i < data.length; i += 4) {
                            if (temp > 0) {
                                data[i] = Math.min(255, data[i] + temp * 40);
                                data[i + 2] = Math.max(0, data[i + 2] - temp * 40);
                            } else {
                                data[i] = Math.max(0, data[i] + temp * 40);
                                data[i + 2] = Math.min(255, data[i + 2] - temp * 40);
                            }
                        }
                    } else if (filter.type === 'vibrance') {
                        const amount = filter.value / 100;
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i], g = data[i + 1], b = data[i + 2];
                            const max = Math.max(r, g, b);
                            const avg = (r + g + b) / 3;
                            const amt = ((Math.abs(max - avg) * 2 / 255) * amount) / 2;
                            data[i] = r + (r - avg) * amt;
                            data[i + 1] = g + (g - avg) * amt;
                            data[i + 2] = b + (b - avg) * amt;
                        }
                    } else if (filter.type === 'gamma') {
                        const gamma = filter.value / 100;
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = 255 * Math.pow(data[i] / 255, gamma);
                            data[i + 1] = 255 * Math.pow(data[i + 1] / 255, gamma);
                            data[i + 2] = 255 * Math.pow(data[i + 2] / 255, gamma);
                        }
                    } else if (filter.type === 'colorize') {
                        const hue = filter.value;
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const h = hue / 360, s = 0.5, l = gray / 255;
                            const c = (1 - Math.abs(2 * l - 1)) * s;
                            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
                            const m = l - c / 2;
                            let r, g, b;
                            if (h < 1/6) { r = c; g = x; b = 0; }
                            else if (h < 2/6) { r = x; g = c; b = 0; }
                            else if (h < 3/6) { r = 0; g = c; b = x; }
                            else if (h < 4/6) { r = 0; g = x; b = c; }
                            else if (h < 5/6) { r = x; g = 0; b = c; }
                            else { r = c; g = 0; b = x; }
                            data[i] = (r + m) * 255;
                            data[i + 1] = (g + m) * 255;
                            data[i + 2] = (b + m) * 255;
                        }
                    } else if (filter.type === 'tonecurve') {
                        const curveType = filter.params?.[0]?.value || "s";
                        const amount = filter.value / 100;
                        const lut = new Uint8Array(256);
                        for (let i = 0; i < 256; i++) {
                            const x = i / 255;
                            let y;
                            if (curveType === "s") {
                                y = (Math.sin((x - 0.5) * Math.PI) + 1) / 2;
                            } else if (curveType === "inverse-s") {
                                y = 0.5 - Math.sin((x - 0.5) * Math.PI) / 2;
                            } else if (curveType === "brighten") {
                                y = Math.pow(x, 0.7);
                            } else if (curveType === "darken") {
                                y = Math.pow(x, 1.5);
                            } else {
                                y = x;
                            }
                            lut[i] = Math.round((x * (1 - amount) + y * amount) * 255);
                        }
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = lut[data[i]];
                            data[i + 1] = lut[data[i + 1]];
                            data[i + 2] = lut[data[i + 2]];
                        }
                    } else if (filter.type === 'edge') {
                        const edgeKernel = [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]];
                        const invert = filter.params?.[0]?.value === "invert";
                        const sourceImageData = new ImageData(new Uint8ClampedArray(imageData.data), w, h);
                        applyConvolution(sourceImageData, imageData, edgeKernel, 1, 0);
                        if (invert) {
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = 255 - data[i];
                                data[i + 1] = 255 - data[i + 1];
                                data[i + 2] = 255 - data[i + 2];
                            }
                        }
                    } else if (filter.type === 'bloom') {
                        const threshold = filter.value;
                        const intensity = (filter.params?.[0]?.value || 50) / 100;
                        for (let i = 0; i < data.length; i += 4) {
                            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            if (brightness >= threshold) {
                                const boost = 1 + (brightness - threshold) / (255 - threshold) * intensity;
                                data[i] = Math.min(255, data[i] * boost);
                                data[i + 1] = Math.min(255, data[i + 1] * boost);
                                data[i + 2] = Math.min(255, data[i + 2] * boost);
                            }
                        }
                    } else if (filter.type === 'duotone') {
                        const amount = filter.value / 100;
                        const shadowColor = filter.params?.[0]?.value || "#1a1a4d";
                        const highlightColor = filter.params?.[1]?.value || "#ff6b9d";
                        const parseShadow = shadowColor.replace('#', '');
                        const shadowR = parseInt(parseShadow.substr(0, 2), 16);
                        const shadowG = parseInt(parseShadow.substr(2, 2), 16);
                        const shadowB = parseInt(parseShadow.substr(4, 2), 16);
                        const parseHighlight = highlightColor.replace('#', '');
                        const highlightR = parseInt(parseHighlight.substr(0, 2), 16);
                        const highlightG = parseInt(parseHighlight.substr(2, 2), 16);
                        const highlightB = parseInt(parseHighlight.substr(4, 2), 16);
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const t = gray / 255;
                            const r = shadowR * (1 - t) + highlightR * t;
                            const g = shadowG * (1 - t) + highlightG * t;
                            const b = shadowB * (1 - t) + highlightB * t;
                            data[i] = data[i] * (1 - amount) + r * amount;
                            data[i + 1] = data[i + 1] * (1 - amount) + g * amount;
                            data[i + 2] = data[i + 2] * (1 - amount) + b * amount;
                        }
                    } else if (filter.type === 'chromatic') {
                        const amount = clamp(Math.round(filter.value), 0, 50);
                        if (amount === 0) return;
                        const direction = filter.params?.[0]?.value || 'horizontal';
                        const original = new Uint8ClampedArray(data);

                        const offsets = {
                            horizontal: { dx: amount, dy: 0 },
                            vertical: { dx: 0, dy: amount },
                            diagonal: { dx: amount, dy: amount }
                        };

                        const { dx, dy } = offsets[direction] || offsets.horizontal;

                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const idx = (y * w + x) * 4;
                                const redX = clamp(x - dx, 0, w - 1);
                                const redY = clamp(y - dy, 0, h - 1);
                                const blueX = clamp(x + dx, 0, w - 1);
                                const blueY = clamp(y + dy, 0, h - 1);
                                const redIdx = (redY * w + redX) * 4;
                                const blueIdx = (blueY * w + blueX) * 4;

                                data[idx] = original[redIdx];
                                data[idx + 1] = original[idx + 1];
                                data[idx + 2] = original[blueIdx + 2];
                            }
                        }
                    } else if (filter.type === 'scanlines') {
                        const intensity = clamp(filter.value / 100, 0, 1);
                        if (intensity === 0) return;
                        const spacing = clamp(
                            parseInt(filter.params?.[0]?.value ?? 4, 10) || 4,
                            2,
                            50,
                        );
                        const thickness = clamp(
                            parseInt(filter.params?.[1]?.value ?? 1, 10) || 1,
                            1,
                            spacing,
                        );

                        for (let y = 0; y < h; y++) {
                            const isDarkBand = (y % spacing) < thickness;
                            for (let x = 0; x < w; x++) {
                                const idx = (y * w + x) * 4;
                                if (isDarkBand) {
                                    data[idx] *= 1 - intensity;
                                    data[idx + 1] *= 1 - intensity;
                                    data[idx + 2] *= 1 - intensity;
                                } else {
                                    const lift = intensity * 0.4;
                                    data[idx] = clamp(data[idx] + (255 - data[idx]) * lift, 0, 255);
                                    data[idx + 1] = clamp(data[idx + 1] + (255 - data[idx + 1]) * lift, 0, 255);
                                    data[idx + 2] = clamp(data[idx + 2] + (255 - data[idx + 2]) * lift, 0, 255);
                                }
                            }
                        }
                    } else if (filter.type === 'colorquant') {
                        const requestedValue = parseInt(filter.value, 10) || 16;
                        const paramLevelsValue = parseInt(
                            getFilterParamValue(filter, "levels", String(requestedValue)),
                            10,
                        );
                        const snappedLevels = snapToAllowedColorLevel(paramLevelsValue);
                        const ditherParam = parseInt(
                            getFilterParamValue(filter, "ditherStrength", "0"),
                            10,
                        ) || 0;
                        const ditherStrength = clamp(ditherParam / 100, 0, 1);
                        applyExactColorQuantization(imageData, snappedLevels, ditherStrength);
                        filter.value = snappedLevels;
                        const levelsParam = filter.params?.find((p) => p.key === "levels");
                        if (levelsParam) {
                            levelsParam.value = String(snappedLevels);
                        }
                    } else if (filter.type === 'haze') {
                        const amount = clamp(filter.value / 100, 0, 1);
                        if (amount === 0) return;
                        const tintHex = filter.params?.[0]?.value || '#ffffff';
                        const tint = parseHexColor(tintHex, { r: 255, g: 255, b: 255 });
                        const contrastFactor = 1 - amount * 0.6;

                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];

                            const tintedR = r * (1 - amount) + tint.r * amount;
                            const tintedG = g * (1 - amount) + tint.g * amount;
                            const tintedB = b * (1 - amount) + tint.b * amount;

                            data[i] = clamp(128 + (tintedR - 128) * contrastFactor, 0, 255);
                            data[i + 1] = clamp(128 + (tintedG - 128) * contrastFactor, 0, 255);
                            data[i + 2] = clamp(128 + (tintedB - 128) * contrastFactor, 0, 255);
                        }
                    }
                };

                const handleImageFile = (file) => {
                    if (!file || !file.type.startsWith("image/")) return;
                    try {
                    if (outputMeta) {
                        outputMeta.classList.add("hidden");
                    }
                    if (outputDimensionsEl) {
                        outputDimensionsEl.textContent = "-";
                    }
                    updateCurrentFileMetadata(file.name, file.type);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        originalImage.src = e.target.result;
                    };
                    reader.onerror = () => {
                        alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                    };
                    reader.readAsDataURL(file);
                    originalImage.onload = () => {
                        imageLoaded = true;
                        processingCanvas.width = originalImage.naturalWidth;
                        processingCanvas.height = originalImage.naturalHeight;
                        placeholderContent.classList.add("hidden");
                        previewContainer.classList.remove("hidden");
                        applyFiltersImmediate();
                    };
                    originalImage.onerror = () => {
                        alert('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
                    };
                    } catch (error) {
                        console.error('ç”»åƒå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
                        alert('ç”»åƒã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
                    }
                };

                ["dragenter", "dragover", "dragleave", "drop"].forEach(
                    (eventName) => {
                        imageDropZone.addEventListener(eventName, (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        });
                    },
                );
                ["dragenter", "dragover"].forEach((eventName) => {
                    imageDropZone.addEventListener(eventName, () =>
                        imageDropZone.classList.add("dragover"),
                    );
                });
                ["dragleave", "drop"].forEach((eventName) => {
                    imageDropZone.addEventListener(eventName, () =>
                        imageDropZone.classList.remove("dragover"),
                    );
                });
                imageDropZone.addEventListener("drop", (e) => {
                    handleImageFile(e.dataTransfer.files[0]);
                });
                fileInput.addEventListener("change", (e) =>
                    handleImageFile(e.target.files[0]),
                );

                uploadBtn.addEventListener("click", () => {
                    fileInput.value = "";
                    fileInput.click();
                });

                batchUploadBtn.addEventListener("click", () => {
                    // Ensure selecting the same files triggers a change event every time
                    batchFileInput.value = "";
                    batchFileInput.click();
                });

                batchFileInput.addEventListener("change", async (e) => {
                    if (isBatchProcessing) {
                        alert('ç¾åœ¨å‡¦ç†ä¸­ã§ã™ã€‚å®Œäº†ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚');
                        e.target.value = '';
                        return;
                    }

                    const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
                    if (files.length === 0) return;

                    // Warning for large batches
                    if (files.length > 50) {
                        if (!confirm(`âš ï¸ è­¦å‘Š: ${files.length}å€‹ã®ç”»åƒã‚’å‡¦ç†ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚\n\nå¤§é‡ã®ç”»åƒå‡¦ç†ã¯æ™‚é–“ãŒã‹ã‹ã‚Šã€ãƒ–ãƒ©ã‚¦ã‚¶ãŒå¿œç­”ã—ãªããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚\n\nç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ`)) {
                            e.target.value = '';
                            return;
                        }
                    }

                    if (!confirm(`${files.length}å€‹ã®ç”»åƒã«ç¾åœ¨ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’é©ç”¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã‹ï¼Ÿ`)) {
                        e.target.value = '';
                        return;
                    }

                    try {
                    console.log('=== ãƒãƒƒãƒå‡¦ç†é–‹å§‹ ===');
                    console.log('ãƒ•ã‚¡ã‚¤ãƒ«æ•°:', files.length);
                    console.log('isBatchProcessing:', isBatchProcessing);

                    isBatchProcessing = true;
                    // Show progress modal
                    progressModal.classList.remove('hidden');
                    progressBar.style.width = '0%';
                    progressText.textContent = `0 / ${files.length}`;

                    // Create ZIP instance
                    const zip = new JSZip();
                    console.log('JSZipã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆå®Œäº†');

                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];

                        await new Promise((resolve, reject) => {
                            const img = new Image();
                            const reader = new FileReader();

                            // Timeout to prevent hanging
                            const timeout = setTimeout(() => {
                                console.error(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${file.name}`);
                                reject(new Error(`Processing timeout for ${file.name}`));
                            }, 30000); // 30 seconds per image

                            const cleanup = () => {
                                clearTimeout(timeout);
                            };

                            reader.onerror = () => {
                                cleanup();
                                console.error(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${file.name}`);
                                resolve(); // Continue processing other files
                            };

                            reader.onload = (ev) => {
                                img.onerror = () => {
                                    cleanup();
                                    console.error(`ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${file.name}`);
                                    resolve(); // Continue processing other files
                                };

                                img.onload = () => {
                                    try {
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d', { willReadFrequently: true });

                                        const activeFilters = filters.filter(f => f.enabled);
                                        const {
                                            remaining: filtersWithoutResize,
                                            targetWidth,
                                            targetHeight
                                        } = splitFiltersForResize(activeFilters, img.naturalWidth, img.naturalHeight);

                                        canvas.width = targetWidth;
                                        canvas.height = targetHeight;

                                        const customFilters = [];
                                        const cssFilters = [];
                                        const directionalBlurFilters = [];

                                        filtersWithoutResize.forEach((f) => {
                                            if (CUSTOM_FILTER_TYPES.includes(f.type)) {
                                                customFilters.push(f);
                                            } else if (
                                                f.type === 'blur' &&
                                                f.params?.[0]?.value &&
                                                f.params[0].value !== 'all'
                                            ) {
                                                directionalBlurFilters.push(f);
                                            } else {
                                                cssFilters.push(f);
                                            }
                                        });

                                        const cssFilterString = cssFilters
                                            .map(f => `${f.type}(${f.value}${f.unit})`)
                                            .join(' ');

                                        ctx.filter = cssFilterString.trim();
                                        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

                                        if (directionalBlurFilters.length > 0) {
                                            ctx.filter = 'none';
                                            let imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
                                            directionalBlurFilters.forEach((filter) => {
                                                const direction = filter.params?.[0]?.value || 'all';
                                                if (direction === 'all') return;
                                                applyDirectionalBlurToImageData(imageData, filter.value, direction);
                                            });
                                            ctx.putImageData(imageData, 0, 0);
                                        }

                                        const perPixelFilters = customFilters.filter(f => f.type !== "pixelate");
                                        const pixelateFilter = customFilters.find(f => f.type === "pixelate");

                                        if (perPixelFilters.length > 0) {
                                            ctx.filter = 'none';
                                            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                                            perPixelFilters.forEach(filter => {
                                                applyCustomFilterToImageData(imageData, filter, canvas.width, canvas.height);
                                            });
                                            ctx.putImageData(imageData, 0, 0);
                                        }

                                        // Apply pixelate filter last
                                        if (pixelateFilter) {
                                            const size = Math.max(1, pixelateFilter.value);
                                            const w = canvas.width;
                                            const h = canvas.height;
                                            const tempCanvas = document.createElement("canvas");
                                            const tempCtx = tempCanvas.getContext("2d");
                                            const downscaleW = Math.ceil(w / size);
                                            const downscaleH = Math.ceil(h / size);
                                            tempCanvas.width = downscaleW;
                                            tempCanvas.height = downscaleH;
                                            tempCtx.drawImage(canvas, 0, 0, w, h, 0, 0, downscaleW, downscaleH);
                                            ctx.imageSmoothingEnabled = false;
                                            ctx.clearRect(0, 0, w, h);
                                            ctx.drawImage(tempCanvas, 0, 0, downscaleW, downscaleH, 0, 0, w, h);
                                            ctx.imageSmoothingEnabled = true;
                                            // Free temp canvas memory
                                            tempCanvas.width = 0;
                                            tempCanvas.height = 0;
                                        }

                                        const { format, outputName } = resolveExportForFile(file);

                                        // Convert canvas to blob and add to ZIP
                                        canvas.toBlob((blob) => {
                                            if (blob) {
                                                zip.file(outputName, blob);
                                            } else {
                                                console.error(`Blobç”Ÿæˆå¤±æ•—: ${file.name}`);
                                            }

                                            // Update progress
                                            const progress = ((i + 1) / files.length) * 100;
                                            progressBar.style.width = `${progress}%`;
                                            progressText.textContent = `${i + 1} / ${files.length}`;

                                            // Clear canvas to free memory
                                            canvas.width = 0;
                                            canvas.height = 0;

                                            cleanup();
                                            resolve();
                                        }, format.mime, format.quality);
                                    } catch (error) {
                                        cleanup();
                                        console.error(`ç”»åƒå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${file.name}`, error);
                                        resolve(); // Continue processing other files
                                    }
                                };
                                img.src = ev.target.result;
                            };
                            reader.readAsDataURL(file);
                        }).catch(err => {
                            console.error(`å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${file.name}`, err);
                            // Continue with next file even if this one fails
                        });
                    }

                    // Generate and download ZIP file
                    progressText.textContent = 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...';
                    console.log('ZIPç”Ÿæˆé–‹å§‹...');

                    const zipBlob = await zip.generateAsync({
                        type: 'blob',
                        compression: "DEFLATE",
                        compressionOptions: { level: 6 }
                    });

                    console.log('ZIPç”Ÿæˆå®Œäº†:', zipBlob.size, 'bytes');

                    const link = document.createElement('a');
                    const fileName = `filtered_images_${Date.now()}.zip`;
                    link.download = fileName;
                    link.href = URL.createObjectURL(zipBlob);
                    link.style.display = 'none';

                    // Add to DOM, click, then remove
                    document.body.appendChild(link);
                    console.log('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹:', fileName);
                    link.click();

                    // Cleanup after download starts
                    setTimeout(() => {
                        try {
                            if (link.parentNode) {
                                document.body.removeChild(link);
                            }
                            URL.revokeObjectURL(link.href);
                            console.log('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
                        } catch (err) {
                            console.error('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', err);
                        }
                    }, 2000);

                    // Hide progress modal and reset state
                    setTimeout(() => {
                        progressModal.classList.add('hidden');
                        isBatchProcessing = false;
                        e.target.value = '';
                        console.log('å‡¦ç†å®Œäº†: ãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ');
                    }, 500);

                    console.log('å‡¦ç†å®Œäº†:', files.length, 'å€‹ã®ç”»åƒ');
                    alert(`${files.length}å€‹ã®ç”»åƒã‚’å‡¦ç†ã—ã¦ZIPãƒ•ã‚¡ã‚¤ãƒ«ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼`);
                    } catch (error) {
                        console.error('ãƒãƒƒãƒå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
                        progressModal.classList.add('hidden');
                        alert(`ãƒãƒƒãƒå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}\n\nã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
                        isBatchProcessing = false;
                        e.target.value = '';
                    }
                });

                saveBtn.addEventListener("click", () => {
                    if (!imageLoaded) return;
                    const { mime, quality } = currentExportFormat;
                    processingCanvas.toBlob((blob) => {
                        if (blob) {
                            const link = document.createElement("a");
                            link.download = currentFileName;
                            link.href = URL.createObjectURL(blob);
                            document.body.appendChild(link);
                            link.click();
                            setTimeout(() => {
                                URL.revokeObjectURL(link.href);
                                if (link.parentNode) {
                                    document.body.removeChild(link);
                                }
                            }, 1000);
                        } else {
                            const fallbackUrl = processingCanvas.toDataURL(mime);
                            const link = document.createElement("a");
                            link.download = currentFileName;
                            link.href = fallbackUrl;
                            link.click();
                        }
                    }, mime, quality);
                });

                // Compress menu toggle
                compressBtn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    compressMenu.classList.toggle("hidden");
                });

                // Close compress menu when clicking outside
                document.addEventListener("click", () => {
                    compressMenu.classList.add("hidden");
                });

                // Compress options
                document.querySelectorAll(".compress-option").forEach(btn => {
                    btn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        if (!imageLoaded) return;

                        const format = e.target.dataset.format;
                        let quality = 0.8;
                        let mimeType = "image/png";
                        let extension = "png";

                        if (format === "jpeg") {
                            const qualityInput = prompt("JPEGå“è³ªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (1-100):", "80");
                            if (qualityInput === null) return;
                            quality = Math.max(1, Math.min(100, parseInt(qualityInput) || 80)) / 100;
                            mimeType = "image/jpeg";
                            extension = "jpg";
                        } else if (format === "png") {
                            // PNG compression via canvas (lossless)
                            mimeType = "image/png";
                            extension = "png";
                            quality = 1.0; // PNG doesn't use quality parameter but we keep it for consistency
                        }

                        const link = document.createElement("a");
                        const fileName = currentFileName.replace(/\.[^.]+$/, `_compressed.${extension}`);
                        link.download = fileName;
                        link.href = processingCanvas.toDataURL(mimeType, quality);
                        link.click();

                        compressMenu.classList.add("hidden");
                    });
                });

                // Resize button
                resizeBtn.addEventListener("click", () => {
                    if (!imageLoaded) return;

                    const currentWidth = originalImage.naturalWidth;
                    const currentHeight = originalImage.naturalHeight;
                    const aspectRatio = currentWidth / currentHeight;

                    const input = prompt(`ç¾åœ¨ã®ã‚µã‚¤ã‚º: ${currentWidth}x${currentHeight}\n\næ–°ã—ã„å¹…ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆé«˜ã•ã¯è‡ªå‹•èª¿æ•´ã•ã‚Œã¾ã™ï¼‰:`, currentWidth);
                    if (input === null) return;

                    const newWidth = parseInt(input);
                    if (isNaN(newWidth) || newWidth <= 0) {
                        alert('ç„¡åŠ¹ãªå€¤ã§ã™');
                        return;
                    }

                    const newHeight = Math.round(newWidth / aspectRatio);

                    // Create temporary canvas for resizing
                    const resizeCanvas = document.createElement('canvas');
                    const resizeCtx = resizeCanvas.getContext('2d');
                    resizeCanvas.width = newWidth;
                    resizeCanvas.height = newHeight;

                    // Draw resized image
                    resizeCtx.drawImage(originalImage, 0, 0, newWidth, newHeight);

                    // Update original image
                    originalImage.src = resizeCanvas.toDataURL('image/png');
                    originalImage.onload = () => {
                        processingCanvas.width = newWidth;
                        processingCanvas.height = newHeight;
                        applyFiltersImmediate();
                        alert(`ãƒªã‚µã‚¤ã‚ºå®Œäº†: ${newWidth}x${newHeight}`);
                    };
                });

                resetBtn.addEventListener("click", () => {
                    filters = [];
                    renderFilterList();
                    applyFiltersImmediate();
                });

                const applyFilters = () => {
                    if (!imageLoaded) return;

                    // Debounce for slider changes
                    if (renderTimeout) {
                        clearTimeout(renderTimeout);
                    }

                    renderTimeout = setTimeout(() => {
                        applyFiltersImmediate();
                    }, 50);
                };

                const applyFiltersImmediate = () => {
                    if (!imageLoaded) return;
                    try {
                    const baseWidth = originalImage.naturalWidth;
                    const baseHeight = originalImage.naturalHeight;
                    const activeFilters = filters.filter((f) => f.enabled);
                    const {
                        remaining: filtersWithoutResize,
                        targetWidth,
                        targetHeight,
                    } = splitFiltersForResize(activeFilters, baseWidth, baseHeight);

                    if (
                        processingCanvas.width !== targetWidth ||
                        processingCanvas.height !== targetHeight
                    ) {
                        processingCanvas.width = targetWidth;
                        processingCanvas.height = targetHeight;
                    }

                    const ctx = processingCanvas.getContext("2d", {
                        willReadFrequently: true,
                    });
                    ctx.clearRect(0, 0, targetWidth, targetHeight);

                    // Separate filters
                    const customFilters = [];
                    const cssFilters = [];
                    const directionalBlurFilters = [];

                    filtersWithoutResize.forEach((filter) => {
                        if (CUSTOM_FILTER_TYPES.includes(filter.type)) {
                            customFilters.push(filter);
                        } else if (
                            filter.type === 'blur' &&
                            filter.params?.[0]?.value &&
                            filter.params[0].value !== 'all'
                        ) {
                            directionalBlurFilters.push(filter);
                        } else {
                            cssFilters.push(filter);
                        }
                    });

                    let cssFilterString = "";
                    cssFilters.forEach((filter) => {
                        const filterValue = `${filter.value}${filter.unit}`;
                        cssFilterString += `${filter.type}(${filterValue}) `;
                    });

                    // 1. Apply CSS filters (fastest)
                    ctx.filter = cssFilterString.trim();
                    ctx.drawImage(originalImage, 0, 0, targetWidth, targetHeight);

                    if (directionalBlurFilters.length > 0) {
                        ctx.filter = 'none';
                        let imageData = ctx.getImageData(
                            0,
                            0,
                            targetWidth,
                            targetHeight,
                        );
                        directionalBlurFilters.forEach((filter) => {
                            const direction = filter.params?.[0]?.value || 'all';
                            if (direction === 'all') return;
                            applyDirectionalBlurToImageData(
                                imageData,
                                filter.value,
                                direction,
                            );
                        });
                        ctx.putImageData(imageData, 0, 0);
                    }

                    const perPixelFilters = customFilters.filter(
                        (f) => f.type !== "pixelate",
                    );
                    const pixelateFilter = customFilters.find(
                        (f) => f.type === "pixelate",
                    );

                    // 2. Apply per-pixel custom filters
                    if (perPixelFilters.length > 0) {
                        ctx.filter = "none"; // Clear CSS filter before getting data
                        let imageData = ctx.getImageData(
                            0,
                            0,
                            targetWidth,
                            targetHeight,
                        );
                        const w = imageData.width;
                        const h = imageData.height;

                        perPixelFilters.forEach((filter) => {
                            applyCustomFilterToImageData(imageData, filter, w, h);
                        });
                        ctx.putImageData(imageData, 0, 0);
                    }

                    // 3. Apply pixelate filter last (most expensive)
                    if (pixelateFilter) {
                        const size = Math.max(1, pixelateFilter.value);
                        const w = targetWidth;
                        const h = targetHeight;

                        const tempCanvas = document.createElement("canvas");
                        const tempCtx = tempCanvas.getContext("2d");
                        const downscaleW = Math.ceil(w / size);
                        const downscaleH = Math.ceil(h / size);
                        tempCanvas.width = downscaleW;
                        tempCanvas.height = downscaleH;

                        tempCtx.drawImage(
                            processingCanvas,
                            0,
                            0,
                            w,
                            h,
                            0,
                            0,
                            downscaleW,
                            downscaleH,
                        );

                        ctx.imageSmoothingEnabled = false;
                        ctx.clearRect(0, 0, w, h);
                        ctx.drawImage(
                            tempCanvas,
                            0,
                            0,
                            downscaleW,
                            downscaleH,
                            0,
                            0,
                            w,
                            h,
                        );
                        ctx.imageSmoothingEnabled = true;
                    }

                    // 4. Update preview image
                    previewImage.src = processingCanvas.toDataURL("image/png");
                    updateOutputDimensions(targetWidth, targetHeight);
                    } catch (error) {
                        console.error('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
                        alert('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç”»åƒã¾ãŸã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    }
                };

                const renderFilterList = () => {
                    filterListEl.innerHTML = "";
                    noFiltersMsg.classList.toggle("hidden", filters.length > 0);

                    filters.forEach((filter, index) => {
                        const item = document.createElement("div");
                        item.className = "filter-item";
                        item.dataset.index = index;
                        const unitDisplay =
                            filter.unitLabel || filter.unit || "";

                        let controlsHTML = '';

                        // Main value control
                        controlsHTML += `
                            <div class="flex items-center gap-2">
                                <input type="range" min="${filter.min}" max="${filter.max}" step="${filter.step || 1}" value="${filter.value}" class="w-full slider" data-index="${index}" data-param="value">
                                <span class="text-xs w-12 text-right">${filter.value}${unitDisplay}</span>
                            </div>
                        `;

                        // Additional parameters
                        if (filter.params) {
                            filter.params.forEach((param, paramIndex) => {
                                if (param.type === 'range') {
                                    const paramUnit = param.unitLabel || param.unit || "";
                                    controlsHTML += `
                                        <div class="flex items-center gap-2 mt-2">
                                            <label class="text-xs text-slate-600 w-20">${param.label}</label>
                                            <input type="range" min="${param.min ?? 0}" max="${param.max ?? 100}" step="${param.step || 1}" value="${param.value}" class="flex-1 slider" data-index="${index}" data-param="${param.key}">
                                            <span class="text-xs w-12 text-right">${param.value}${paramUnit}</span>
                                        </div>
                                    `;
                                } else if (param.type === 'number') {
                                    const minAttr = typeof param.min !== 'undefined' ? `min="${param.min}"` : '';
                                    const maxAttr = typeof param.max !== 'undefined' ? `max="${param.max}"` : '';
                                    const stepAttr = typeof param.step !== 'undefined' ? `step="${param.step}"` : 'step="1"';
                                    const paramUnit = param.unitLabel || param.unit || "";
                                    controlsHTML += `
                                        <div class="flex items-center gap-2 mt-2">
                                            <label class="text-xs text-slate-600 w-20">${param.label}</label>
                                            <input type="number" class="flex-1 text-xs p-1 rounded border border-slate-300 number-input" data-index="${index}" data-param="${param.key}" value="${param.value}" ${minAttr} ${maxAttr} ${stepAttr}>
                                            <span class="text-xs text-slate-500 whitespace-nowrap">${paramUnit}</span>
                                        </div>
                                    `;
                                } else if (param.type === 'color') {
                                    controlsHTML += `
                                        <div class="flex items-center gap-2 mt-2">
                                            <label class="text-xs text-slate-600 w-20">${param.label}</label>
                                            <input type="color" value="${param.value}" class="flex-1 h-8 rounded" data-index="${index}" data-param="${param.key}">
                                        </div>
                                    `;
                                } else if (param.type === 'select') {
                                    const optionsHTML = param.options.map(opt =>
                                        `<option value="${opt.value}" ${opt.value === param.value ? 'selected' : ''}>${opt.label}</option>`
                                    ).join('');
                                    controlsHTML += `
                                        <div class="flex items-center gap-2 mt-2">
                                            <label class="text-xs text-slate-600 w-20">${param.label}</label>
                                            <select class="flex-1 text-xs p-1 rounded border border-slate-300" data-index="${index}" data-param="${param.key}">
                                                ${optionsHTML}
                                            </select>
                                        </div>
                                    `;
                                }
                            });
                        }

                        item.innerHTML = `
                    <div class="flex items-center gap-2">
                        <span class="handle">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                        </span>
                        <span class="flex-grow text-sm font-medium capitalize">${filter.label}</span>
                        <button class="toggle-visibility-btn p-1" data-index="${index}">
                            ${
                                filter.enabled
                                    ? '<svg class="w-5 h-5 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>'
                                    : '<svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.542-7 1.274-4.057 5.064-7 9.542-7 .847 0 1.67.127 2.454.364m-6.024 4.458a3 3 0 114.242 4.242l-4.242-4.242z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3l18 18"></path></svg>'
                            }
                        </button>
                        <button class="remove-filter-btn p-1 text-red-500 hover:text-red-700" data-index="${index}">
                           <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                        </button>
                    </div>
                    <div>
                        ${controlsHTML}
                    </div>
                `;
                        filterListEl.appendChild(item);
                    });
                };

                const addFilter = (type) => {
                                        const filterInstance = instantiateFilter(type);
                    if (!filterInstance) {
                        console.warn(`æœªå¯¾å¿œã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—: ${type}`);
                        return;
                    }
                    filters.push(filterInstance);
                    renderFilterList();
                    applyFiltersImmediate();
                };

                // Tab switching logic
                filterTabsContainer.addEventListener("click", (e) => {
                    const button = e.target.closest("button");
                    if (!button) return;

                    filterTabsContainer
                        .querySelectorAll(".tab-btn")
                        .forEach((btn) => btn.classList.remove("active"));
                    button.classList.add("active");

                    tabPanels.forEach((panel) => panel.classList.add("hidden"));
                    document
                        .getElementById(`tab-content-${button.dataset.tab}`)
                        .classList.remove("hidden");
                });

                // Preset configurations
                const presets = {
                    sunset: [
                        { type: 'temperature', value: 80 },
                        { type: 'saturate', value: 140 },
                        { type: 'brightness', value: 110 },
                        { type: 'contrast', value: 115 },
                    ],
                    night: [
                        { type: 'brightness', value: 70 },
                        { type: 'contrast', value: 130 },
                        { type: 'saturate', value: 80 },
                        { type: 'temperature', value: 20 },
                        { type: 'colorize', value: 240 },
                    ],
                    game: [
                        { type: 'saturate', value: 180 },
                        { type: 'contrast', value: 140 },
                        { type: 'vibrance', value: 150 },
                        { type: 'sharpen', value: 70 },
                        { type: 'pixelate', value: 4 },
                    ],
                    'dot-art': [
                        {
                            type: 'colorquant',
                            value: 32,
                            params: [
                                { key: 'levels', value: '32' },
                                { key: 'ditherStrength', value: 30 }
                            ]
                        },
                        {
                            type: 'dither',
                            value: 65,
                            params: [
                                { key: 'palette', value: 'original' },
                                { key: 'pattern', value: 'stagger' },
                                { key: 'scale', value: 1 }
                            ]
                        },
                        { type: 'pixelate', value: 2 },
                        { type: 'contrast', value: 120 },
                        { type: 'saturate', value: 105 },
                        { type: 'sharpen', value: 70 },
                    ],
                    warm: [
                        { type: 'temperature', value: 85 },
                        { type: 'saturate', value: 120 },
                        { type: 'brightness', value: 105 },
                    ],
                    cool: [
                        { type: 'temperature', value: 15 },
                        { type: 'saturate', value: 120 },
                        { type: 'brightness', value: 105 },
                    ],
                    'retro-gb': [
                        {
                            type: 'dither',
                            value: 100,
                            params: [
                                { key: 'palette', value: 'gb' },
                                { key: 'pattern', value: 'mesh' },
                                { key: 'scale', value: 2 }
                            ]
                        },
                        {
                            type: 'tonecurve',
                            value: 60,
                            params: [
                                { key: 'curveType', value: 's' }
                            ]
                        },
                        {
                            type: 'scanlines',
                            value: 28,
                            params: [
                                { key: 'spacing', value: 6 },
                                { key: 'thickness', value: 2 }
                            ]
                        }
                    ],
                    film: [
                        {
                            type: 'tonecurve',
                            value: 75,
                            params: [
                                { key: 'curveType', value: 's' }
                            ]
                        },
                        { type: 'temperature', value: 55 },
                        { type: 'colorize', value: 30 },
                        {
                            type: 'vignette',
                            value: 60,
                            params: [
                                { key: 'shape', value: 'circle' }
                            ]
                        },
                        { type: 'noise', value: 12 }
                    ],
                    'neon-city': [
                        { type: 'vibrance', value: 185 },
                        { type: 'saturate', value: 170 },
                        {
                            type: 'chromatic',
                            value: 14,
                            params: [
                                { key: 'direction', value: 'diagonal' }
                            ]
                        },
                        {
                            type: 'scanlines',
                            value: 45,
                            params: [
                                { key: 'spacing', value: 4 },
                                { key: 'thickness', value: 1 }
                            ]
                        },
                        {
                            type: 'bloom',
                            value: 210,
                            params: [
                                { key: 'intensity', value: 150 }
                            ]
                        }
                    ],
                };

                const applyPreset = (presetName) => {
                    const preset = presets[presetName];
                    if (!preset) return;

                    // Clear existing filters
                    filters = [];

                    // Add preset filters
                    preset.forEach((filterConfig) => {
                        const { type, ...override } = filterConfig;
                        const filterInstance = instantiateFilter(type, override);
                        if (filterInstance) {
                            filters.push(filterInstance);
                        }
                    });

                    renderFilterList();
                    applyFiltersImmediate();
                };

                // Preset button clicks
                document.querySelectorAll(".preset-btn").forEach((btn) => {
                    btn.addEventListener("click", (e) => {
                        const presetName = e.currentTarget.dataset.preset;
                        if (presetName) {
                            applyPreset(presetName);
                        }
                    });
                });

                // Add filter button clicks
                document.querySelectorAll(".tab-panel").forEach((panel) => {
                    panel.addEventListener("click", (e) => {
                        const button = e.target.closest("button");
                        if (button && button.dataset.filter) {
                            addFilter(button.dataset.filter);
                        }
                    });
                });

                filterListEl.addEventListener("input", (e) => {
                    const index = e.target.dataset.index;
                    const param = e.target.dataset.param;

                    if (e.target.classList.contains("slider")) {
                        const rawValue = e.target.value;
                        const targetFilter = filters[index];
                        const unitDisplay = targetFilter.unitLabel || targetFilter.unit || "";

                        if (param === "value") {
                            if (targetFilter.type === "colorquant") {
                                const numericValue = parseInt(rawValue, 10) || 16;
                                const snapped = snapToAllowedColorLevel(numericValue);
                                targetFilter.value = snapped;
                                e.target.value = snapped;
                                e.target.nextElementSibling.textContent = `${snapped}${unitDisplay}`;
                                const levelsParam = targetFilter.params?.find((p) => p.key === "levels");
                                if (levelsParam) {
                                    levelsParam.value = String(snapped);
                                }
                            } else {
                                targetFilter.value = rawValue;
                                e.target.nextElementSibling.textContent = `${rawValue}${unitDisplay}`;
                            }
                        } else {
                            // Update parameter value
                            const paramObj = targetFilter.params?.find(p => p.key === param);
                            if (paramObj) {
                                paramObj.value = rawValue;
                                const unitDisplay = paramObj.unitLabel || paramObj.unit || "";
                                e.target.nextElementSibling.textContent = `${rawValue}${unitDisplay}`;
                            }
                        }
                        applyFilters();
                    } else if (e.target.type === "number") {
                        const paramObj = filters[index].params?.find(p => p.key === param);
                        if (paramObj) {
                            paramObj.value = e.target.value;
                        }
                        applyFilters();
                    } else if (e.target.type === "color") {
                        const paramObj = filters[index].params?.find(p => p.key === param);
                        if (paramObj) {
                            paramObj.value = e.target.value;
                        }
                        applyFilters();
                    }
                });

                filterListEl.addEventListener("click", (e) => {
                    const removeBtn = e.target.closest(".remove-filter-btn");
                    if (removeBtn) {
                        filters.splice(removeBtn.dataset.index, 1);
                        renderFilterList();
                        applyFilters();
                        return;
                    }
                    const visibilityBtn = e.target.closest(
                        ".toggle-visibility-btn",
                    );
                    if (visibilityBtn) {
                        const index = visibilityBtn.dataset.index;
                        filters[index].enabled = !filters[index].enabled;
                        renderFilterList();
                        applyFilters();
                    }
                });

                filterListEl.addEventListener("change", (e) => {
                    if (e.target.tagName === "SELECT") {
                        const index = e.target.dataset.index;
                        const param = e.target.dataset.param;
                        const targetFilter = filters[index];
                        let newValue = e.target.value;
                        if (targetFilter.type === "colorquant" && param === "levels") {
                            const numericValue = parseInt(newValue, 10) || 16;
                            const snapped = snapToAllowedColorLevel(numericValue);
                            targetFilter.value = snapped;
                            const unitDisplay = targetFilter.unitLabel || targetFilter.unit || "";
                            const slider = filterListEl.querySelector(`input.slider[data-index="${index}"][data-param="value"]`);
                            if (slider) {
                                slider.value = snapped;
                                slider.nextElementSibling.textContent = `${snapped}${unitDisplay}`;
                            }
                            newValue = String(snapped);
                            if (newValue !== e.target.value) {
                                e.target.value = newValue;
                            }
                        }
                        const paramObj = targetFilter.params?.find(p => p.key === param);
                        if (paramObj) {
                            paramObj.value = newValue;
                        }
                        applyFilters();
                    }
                });

                new Sortable(filterListEl, {
                    animation: 150,
                    handle: ".handle",
                    ghostClass: "ghost",
                    onEnd: (evt) => {
                        const [movedItem] = filters.splice(evt.oldIndex, 1);
                        filters.splice(evt.newIndex, 0, movedItem);
                        renderFilterList();
                        applyFilters();
                    },
                });

                previewImage.addEventListener("dragstart", (e) => {
                    if (imageLoaded) {
                        e.dataTransfer.setData(
                            "text/uri-list",
                            previewImage.src,
                        );
                        e.dataTransfer.setData(
                            "text/html",
                            `<img src="${previewImage.src}">`,
                        );
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl+S or Cmd+S: Save
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        if (imageLoaded) {
                            saveBtn.click();
                        }
                    }
                    // Ctrl+O or Cmd+O: Open
                    if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                        e.preventDefault();
                        uploadBtn.click();
                    }
                    // Ctrl+R or Cmd+R: Reset (override browser refresh)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                        e.preventDefault();
                        if (confirm('ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
                            resetBtn.click();
                        }
                    }
                    // Ctrl+I or Cmd+I: Resize
                    if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                        e.preventDefault();
                        if (imageLoaded) {
                            resizeBtn.click();
                        }
                    }
                });

                // Initialize view
                renderFilterList();
            });
        </script>
    </body>
</html>
